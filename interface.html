<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta content="width=device-width,initial-scale=1" name="viewport">
  <meta name="description" content="The Cell Programming Language">

  <title>The Cell Programming Language</title>

  <link href="./fonts.css" rel="stylesheet" type="text/css" media="screen">
  <link href="./main.css" rel="stylesheet">
</head>

<body>
  <div id="container">

    <header id="topbar">
    </header>

    <div id="main-container">
      <div id="main">
        <article class="content">
<h2>Interfacing with C++</h2>

<p>When you compile a Cell program, the compiler does not generate a binary executable. Instead, it generates a text file containing code in the chosen output language. The only output language that is available at the moment is C++. If you define a <code class="inline-code-box"><span class="inline-code">Main(..)</span></code> procedure in you Cell code, the generated code can then be handed over to a C++ compiler to generate an executable file. That's how for instance the Cell compiler itself is built, and also the simplest way to build a program that tests your automata. But if you don't define a <code class="inline-code-box"><span class="inline-code">Main(..)</span></code> procedure, the compiler will generate a set of classes, one for each type of automaton in your Cell code, that can be used to instantiate and manipulate the corresponding automata from your C++ code. The declarations of those classes will be contained in one of the two files generated by the compiler, <code class="inline-code-box"><span class="inline-code">generated.h</span></code>, while the second file <code class="inline-code-box"><span class="inline-code">generated.cpp</span></code> will contain the corresponding implementations. In this chapter we'll go through the interface of the generated classes and explain how to use them, and what each method is for.</p>

<p>The classes generated by the compiler are not supposed be used directly in your code: you should instead create a wrapper class for each of them, and use those instead. Having a level of indirection between your own C++ code and the generated one is useful for several reasons:</p>

<ul><li>In order to pass data back and forth from the host language to Cell, you'll inevitably have to manually convert the native C++ data structures in the format that is accepted by the generated code and vice versa. You really don't want to repeatedly perform those conversions all over your codebase: it's much better to have all of them in just one place.</li><li>The interface of those generated classes is not yet stable, and it may change even radically with future versions of the compiler. If you hide them inside wrapper classes, all the changes can be dealt with in just one place.</li><li>The naming conventions of all the generated methods are rather ugly, as they are designed to avoid name clashes, not to be elegant. With the wrapper classes, on the other hand, you're free to use whatever naming convention you use in the rest of your program.</li></ul>


<h3>Data conversion</h3>

<p>The most annoying and time-consuming part of using the classes generated by the Cell compiler from your own C++ code is of course converting data back and forth between the C++ and Cell representations. Let's focus on passing data from C++ to Cell first, since that's simpler. There's a number of simple Cell data types that are mapped directly to a corresponding C++ type. They are shown in the following table:</p>

<p><table class="types-table">
  <tr>
    <th>Cell</th>
    <th>C++</th>
  </tr>
  <tr>
    <td>Int</td>
    <td>long long</td>
  </tr>
  <tr>
    <td>Float</td>
    <td>double</td>
  </tr>
  <tr>
    <td>Bool</td>
    <td>bool</td>
  </tr>
  <tr>
    <td>String</td>
    <td>const char * (UTF-8)</td>
  </tr>
</table>
</p>

<p>Note that if you're passing in a string that contains characters that cannot be represented by 7-bit ascii, you'll need to encode them in UFT-8 format. When dealing with more complex data types that are not in the above table, you're expected to pass a string (that is, a <code class="inline-code-box"><span class="inline-code">const char *</span></code> pointer) that contains the textual representation of a Cell value. That's neither elegant nor particularly efficient, but at least it's simple and straighforward.</p>

<p>The mapping is different, and more complex, when passing data back from Cell to C++. In this case it's of course not feasible to use the textual representation of values as an exchange format, because parsing those strings would be too much of a burden on the C++ side. So first of all the list of data types that have a direct mapping is longer:</p>

<p><table class="types-table">
  <tr>
    <th>Cell</th>
    <th>C++</th>
  </tr>
  <tr>
    <td>Int</td>
    <td>long long</td>
  </tr>
  <tr>
    <td>Float</td>
    <td>double</td>
  </tr>
  <tr>
    <td>Bool</td>
    <td>bool</td>
  </tr>
  <tr>
    <td>Symbol</td>
    <td>const char *</td>
  </tr>
  <tr>
    <td>String</td>
    <td>std::string (UTF-8)</td>
  </tr>
  <tr>
    <td>(T1, T2, ...)</td>
    <td>std::tuple&lt;T1', T2', ...&gt;</td>
  </tr>
  <tr>
    <td>T*</td>
    <td>std::vector&lt;T'&gt;</td>
  </tr>
  <tr>
    <td>[T]</td>
    <td>std::vector&lt;T'&gt;</td>
  </tr>
  <tr>
    <td>[T1, T2]</td>
    <td>std::vector&lt;std::tuple&lt;T1', T2'&gt&gt;</td>
  </tr>
  <tr>
    <td>[T1, T2, T3]</td>
    <td>std::vector&lt;std::tuple&lt;T1', T2', T3'&gt&gt;</td>
  </tr>
  <tr>
    <td>any_tag(T)</td>
    <td>T'</td>
</table>
</p>

<p>The above table should be mostly self-explanatory, but there's a few things that need explaining:</p>

<ul><li>Symbols are returned as pointers to strings containing their textual representation. For example, <code class="inline-code-box"><span class="inline-code">nothing</span></code> is returned as a pointer to the <code class="inline-code-box"><span class="inline-code">C</span></code> string <code class="inline-code-box"><span class="inline-code">"nothing"</span></code>. Those strings are kept in static memory, or something equivalent to it. DO NOT TRY TO DEALLOCATE THEM.</li><li>Strings are returned as <code class="inline-code-box"><span class="inline-code">std::string</span></code> objects, again in UTF-8 format.</li><li>Aggregate types like sequences, tuples, sets and relations are mapped directly to the corresponding C++ data types only if the types of their elements have a direct mapping as well.</li><li>Tagged types can be mapped directly to a C++ type only if the tag is a known symbol and the type of the untagged value in turn has a direct mapping to a C++ type. In this case, the tag is simply discarded and the  untagged value is returned.</li></ul>

<p>The data types that cannot be mapped directly to C++ equivalents (the most important of which are records and union types) are returned as a pointer to an object of the <code class="inline-code-box"><span class="inline-code">cell::Value</span></code> class whose declaration is included in the file <code class="inline-code-box"><span class="inline-code">generated.h</span></code>. <code class="inline-code-box"><span class="inline-code">cell::Value</span></code> is an abstract class, that contains only pure virtual methods and no member variables. Its declaration is shown here:</p>

<p><figure class="highlight"><section><pre style="margin: 0; line-height: 125%"><code><span class='k'>namespace</span> cell {
  <span class='k'>class</span> <span class='m'>Value</span> {
  <span class='n'>public:</span>
    <span class='k'>virtual</span> <span class='b'>bool</span> is_symb() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>bool</span> is_int() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>bool</span> is_float() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>bool</span> is_seq() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>bool</span> is_set() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>bool</span> is_bin_rel() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>bool</span> is_tern_rel() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>bool</span> is_tagged() = <span class='n'>0</span>;

    <span class='k'>virtual</span> <span class='b'>bool</span> is_string() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>bool</span> is_record() = <span class='n'>0</span>;

    <span class='k'>virtual</span> <span class='k'>const</span> <span class='b'>char</span> *as_symb() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>long</span> <span class='b'>long</span> as_int() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>double</span> as_float() = <span class='n'>0</span>;

    <span class='k'>virtual</span> <span class='b'>unsigned</span> <span class='b'>int</span> size() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='m'>Value</span> *item(<span class='b'>unsigned</span> <span class='b'>int</span>) = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>void</span> entry(<span class='b'>unsigned</span> <span class='b'>int</span>, <span class='m'>Value</span> *&amp;, <span class='m'>Value</span> *&amp;) = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>void</span> entry(<span class='b'>unsigned</span> <span class='b'>int</span>, <span class='m'>Value</span> *&amp;, <span class='m'>Value</span> *&amp;, <span class='m'>Value</span> *&amp;) = <span class='n'>0</span>;

    <span class='k'>virtual</span> <span class='k'>const</span> <span class='b'>char</span> *tag() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='m'>Value</span> *untagged() = <span class='n'>0</span>;

    <span class='k'>virtual</span> std::string as_str() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='m'>Value</span> *lookup(<span class='k'>const</span> <span class='b'>char</span> *) = <span class='n'>0</span>;

    <span class='k'>virtual</span> std::string printed() = <span class='n'>0</span>;
    <span class='k'>virtual</span> <span class='b'>void</span> print(std::ostream <span style="color: #333333">&amp;</span>os) = <span class='n'>0</span>;
  };
}
</code></pre></section></figure>
</p>

<p>This is the common superclass/interface of a number of concrete classes each of which is used to represent a particular type of Cell value: symbols, integers, floating point numbers, sequences, sets, binary and ternary relations and tagged values. These concrete classes are hidden from the user, and they can be manipulated only through their common "fat" interface, whose methods can be divided into three groups. The first one comprises all the <code class="inline-code-box"><span class="inline-code">bool is_*()</span></code> methods, which are used to discover the type of the value represented by the target object. Then there's a group of methods that are used to actually access the data held by those objects:</p>

<p><figure class="highlight"><section><pre style="margin: 0; line-height: 125%"><code>
  <span class='c'>// Defined only for symbols. Return a pointer to a string</span>
  <span class='c'>// that contains the textual representation of the symbol</span>
  <span class='c'>// Do not try to deallocate the returned string</span>
  <span class='k'>const</span> <span class='b'>char</span> *as_symb();

  <span class='c'>// Defined only for integers</span>
  <span class='c'>// Returns the value as a 64-bit signed integer</span>
  <span class='b'>long</span> <span class='b'>long</span> as_int();

  <span class='c'>// Defined only for floating point numbers</span>
  <span class='c'>// Returns the value as a double precision floating point number</span>
  <span class='b'>double</span> as_float();

  <span class='c'>// Defined for all collection types:</span>
  <span class='c'>// sequences, sets, binary and ternary relations</span>
  <span class='b'>unsigned</span> <span class='b'>int</span> size();

  <span class='c'>// Defined only for sequences and sets</span>
  <span class='c'>// Returns the i-th value in the collection</span>
  <span class='c'>// In the case of sets, elements are arranged</span>
  <span class='c'>// in an implementation-defined order</span>
  <span class='m'>Value</span> *item(<span class='b'>unsigned</span> <span class='b'>int</span>);

  <span class='c'>// Defined only for binary relations</span>
  <span class='c'>// Returns the i-th pair in the relation</span>
  <span class='c'>// Pairs are arranged in an implementation-defined order</span>
  <span class='b'>void</span> entry(<span class='b'>unsigned</span> <span class='b'>int</span>, <span class='m'>Value</span> *&amp;, <span class='m'>Value</span> *&amp;);

  <span class='c'>// Defined only for ternary relations</span>
  <span class='c'>// Returns the i-th triple in the relation</span>
  <span class='c'>// Entries are arranged in an implementation-defined order</span>
  <span class='b'>void</span> entry(<span class='b'>unsigned</span> <span class='b'>int</span>, <span class='m'>Value</span> *&amp;, <span class='m'>Value</span> *&amp;, <span class='m'>Value</span> *&amp;);

  <span class='c'>// Defined only for tagged values</span>
  <span class='c'>// Returns the textual representation of the tag</span>
  <span class='c'>// Again, do not try to deallocate the returned string</span>
  <span class='k'>const</span> <span class='b'>char</span> *tag();

  <span class='c'>// Defined only for tagged values</span>
  <span class='c'>// Returns the value without the tag</span>
  <span class='m'>Value</span> *untagged();

  <span class='c'>// Defined only for strings</span>
  <span class='c'>// Returns the string in UTF-8 format</span>
  std::string as_str();

  <span class='c'>// Defined only for records</span>
  <span class='c'>// Returns the value of the corresponding field</span>
  <span class='c'>// The only parameter is the textual representation of the</span>
  <span class='c'>// field symbol, e.g. point.lookup("x")</span>
  <span class='m'>Value</span> *lookup(<span class='k'>const</span> <span class='b'>char</span> *);
</code></pre></section></figure>
</p>

<p>Each of these methods are defined only for a subset of the subclasses of <code class="inline-code-box"><span class="inline-code">cell::Value</span></code>, and if used with the wrong concrete class will just throw an exception. <code class="inline-code-box"><span class="inline-code">long long as_int()</span></code>, for example, can only be used if the target object actually holds an integer value, which can be checked using the <code class="inline-code-box"><span class="inline-code">bool is_int()</span></code> query methods.</p>

<p>The last two methods, <code class="inline-code-box"><span class="inline-code">string printed()</span></code> and <code class="inline-code-box"><span class="inline-code">void print(std::ostream &os)</span></code>, are used to generate the textual representation of the value, which is returned as a <code class="inline-code-box"><span class="inline-code">string</span></code> by the first and written to the provided <code class="inline-code-box"><span class="inline-code">ostream</span></code> object by the second.</p>

<p>When the methods of automaton-derived generated classes need to return a <code class="inline-code-box"><span class="inline-code">cell::Value</span></code> object they always do it using a <code class="inline-code-box"><span class="inline-code">std::unique_ptr&lt;cell::Value&gt;</span></code> smart pointer. Once the smart pointer goes out of scope, the <code class="inline-code-box"><span class="inline-code">cell::Value</span></code> object it points to is automatically deleted. If you get a pointer to one of its subobjects, using methods of the <code class="inline-code-box"><span class="inline-code">cell::Value</span></code> interface like for instance <code class="inline-code-box"><span class="inline-code">Value *item(unsigned int)</span></code>, do not try to delete it. Those subobjects are "owned" by the object they belong to, and are automatically deleted along with it. It goes without saying that those pointers cannot be used anymore once the root object is deleted.</p>


<h3>Static automata</h3>

<p>Let's take a look at the interface of the classes produced by the compilation of a static automaton. We'll start with a very simple one, <code class="inline-code-box"><span class="inline-code">Counter</span></code>:</p>

<p><figure class="highlight"><section><pre style="margin: 0; line-height: 125%"><code><span class='k'>namespace</span> generated {
  <span class='k'>class</span> <span class='m'>Counter</span> {
  <span class='b'>public:</span>
    Counter();
    ~Counter();

    std::<span class='b'>unique_ptr</span>&lt;cell::<span class='m'>Value</span>&gt; read_state();
    <span class='b'>void</span> set_state(<span class='k'>const</span> <span class='b'>char</span> *);

    <span class='b'>void</span> execute(<span class='k'>const</span> <span class='b'>char</span> *);

    <span class='b'>long long</span> get_Value();
    <span class='b'>long long</span> get_Updates();

  <span class='b'>private:</span>
    <span class='b'>void</span> *ptr;
  };
}
</code></pre></section></figure>
</p>

<p>As you can see, the generated C++ class has the same name of the Cell automaton it derives from, and is placed in the <code class="inline-code-box"><span class="inline-code">generated</span></code> namespace. The first three methods, <code class="inline-code-box"><span class="inline-code">read_state()</span></code>, <code class="inline-code-box"><span class="inline-code">set_state(..)</span></code> and <code class="inline-code-box"><span class="inline-code">execute(..)</span></code>, are the same for all static automata. All other methods are just accessors that are specific to a particular automaton, and can be used to read pieces of its state, or to invoke its methods.</p>

<p>The <code class="inline-code-box"><span class="inline-code">read_state()</span></code> methods is the equivalent of the <code class="inline-code-box"><span class="inline-code">read</span></code> instruction in Cell: it takes a snapshot of the state of the automaton and returns it as a <code class="inline-code-box"><span class="inline-code">cell::Value</span></code> object. As explained earlier, once the <code class="inline-code-box"><span class="inline-code">unique_ptr</span></code> object goes out of scope the returned object and all its subobjects are automatically deleted. Saving the state of an automaton to a file in text form can be done with the instruction <code class="inline-code-box"><span class="inline-code">instance.read_state().print(ofs);</span></code>, where <code class="inline-code-box"><span class="inline-code">ofs</span></code> is a valid instance of <code class="inline-code-box"><span class="inline-code">std::ofstream</span></code>.</p>

<p><code class="inline-code-box"><span class="inline-code">set_state(..)</span></code> is used to set the state of an automaton instance, and is the equivalent of the <code class="inline-code-box"><span class="inline-code">write</span></code> instruction in Cell. It can be used at any time in the life of the automaton instance, any number of times. The new state has to be provided in text form. Here's an example:</p>

<figure class="highlight">
<section>
<pre><code>counter.set_state(<span class='s'>"(value: -10, updates: 0)"</span>);
</section>
</figure>
</code></pre>

<p>If the provided state is not a valid one, <code class="inline-code-box"><span class="inline-code">set_state(..)</span></code> will throw an exception. The generated code only throws <code class="inline-code-box"><span class="inline-code">long long</span></code> values, which can of course be caught with a <code class="inline-code-box"><span class="inline-code">catch (long long e) {...}</span></code> instruction. If the provided string cannot be parsed, the value thrown will specify the offset of the parsing error. If on the other hand the string encodes a valid Cell value but that value is not a valid state for the automaton in question the generated code will just throw <code class="inline-code-box"><span class="inline-code">0LL</span></code>. If the operation fails, the automaton instance will just retain the state it had before, and will still be perfecly functional.</p>

<p><code class="inline-code-box"><span class="inline-code">execute(..)</span></code> is used to send the automaton a message, which has to be passed in text form. A few examples:</p>

<figure class="highlight">
<section>
<pre><code>counter.execute(<span class='s'>"incr"</span>);
counter.execute(<span class='s'>"decr"</span>);
counter.execute(<span class='s'>"reset"</span>);
counter.execute(<span class='s'>"reset(-1)"</span>);
</section>
</figure>
</code></pre>

<p>Errors handling is the same as before. There's just one extra case to be aware of: if the argument encodes a valid message for the target automaton, but the message handler fails, <code class="inline-code-box"><span class="inline-code">execute(..)</span></code> will throw the value <code class="inline-code-box"><span class="inline-code">0LL</span></code>. In any case, if the operation fails, the automaton will remain fully operational, and its state will be left untouched.</p>

<p>The last two methods, <code class="inline-code-box"><span class="inline-code">get_Value()</span></code> and <code class="inline-code-box"><span class="inline-code">get_Updates()</span></code>, are <code class="inline-code-box"><span class="inline-code">Counter</span></code>-specific accessors that return the values of the <code class="inline-code-box"><span class="inline-code">value</span></code> and <code class="inline-code-box"><span class="inline-code">update</span></code> member variables respectively. Note that the types of such variables is just <code class="inline-code-box"><span class="inline-code">Int</span></code>, which can be mapped directly to <code class="inline-code-box"><span class="inline-code">long long</span></code> in C++, with no need to use <code class="inline-code-box"><span class="inline-code">cell:Value</span></code>.</p>

<p>Let's now take a look at a more complex automaton, <code class="inline-code-box"><span class="inline-code">Supply</span></code>. Here's the declaration of the generated C++ class:</p>

<p><figure class="highlight"><section><pre style="margin: 0; line-height: 125%"><code><span class='k'>class</span> <span class='m'>Supply</span> {
<span class='b'>public:</span>
  Supply();
  ~Supply();

  std::unique_ptr&lt;cell::<span class='m'>Value</span>&gt; read_state();
  <span class='b'>void</span> set_state(<span class='k'>const</span> char *);
  <span class='b'>void</span> execute(<span class='k'>const</span> char *);

  <span class='b'>long</span> <span class='b'>long</span> get_Next_part_id();
  <span class='b'>long</span> <span class='b'>long</span> get_Next_supplier_id();

  <span class='b'>bool</span> in_Part(<span class='k'>const</span> char *);
  std::vector&lt;<span class='b'>long</span> <span class='b'>long</span>&gt; get_Part();

  <span class='b'>bool</span> in_Supplier(<span class='k'>const</span> char *);
  std::vector&lt;<span class='b'>long</span> <span class='b'>long</span>&gt; get_Supplier();

  <span class='b'>bool</span> in_Code(<span class='k'>const</span> char *, <span class='k'>const</span> char *);
  std::vector&lt;std::tuple&lt;<span class='b'>long</span> <span class='b'>long</span>, std::string&gt;&gt; get_Code();

  <span class='b'>bool</span> in_Phone(<span class='k'>const</span> char *, <span class='k'>const</span> char *);
  std::vector&lt;std::tuple&lt;<span class='b'>long</span> <span class='b'>long</span>, std::string&gt;&gt; get_Phone();

  <span class='b'>bool</span> in_Sells(<span class='k'>const</span> char *, <span class='k'>const</span> char *);
  std::vector&lt;std::tuple&lt;<span class='b'>long</span> <span class='b'>long</span>, <span class='b'>long</span> <span class='b'>long</span>&gt;&gt; get_Sells();

  <span class='b'>bool</span> in_Name(<span class='k'>const</span> char *, <span class='k'>const</span> char *);
  <span class='b'>bool</span> lookup_Name(<span class='k'>const</span> char *, std::string &amp;);
  std::vector&lt;std::tuple&lt;<span class='b'>long</span> <span class='b'>long</span>, std::string&gt;&gt; get_Name();

  <span class='b'>bool</span> in_Address(<span class='k'>const</span> char *, <span class='k'>const</span> char *);
  <span class='b'>bool</span> lookup_Address(<span class='k'>const</span> char *, std::string &amp;);
  std::vector&lt;std::tuple&lt;<span class='b'>long</span> <span class='b'>long</span>, std::string&gt;&gt; get_Address();

  <span class='b'>bool</span> in_Description(<span class='k'>const</span> char *, <span class='k'>const</span> char *);
  <span class='b'>bool</span> lookup_Description(<span class='k'>const</span> char *, std::string &amp;);
  std::vector&lt;std::tuple&lt;<span class='b'>long</span> <span class='b'>long</span>, std::string&gt;&gt; get_Description();

  <span class='b'>bool</span> in_Availability(<span class='k'>const</span> char *, <span class='k'>const</span> char *, <span class='b'>long</span> <span class='b'>long</span>);
  std::vector&lt;std::tuple&lt;<span class='b'>long</span> <span class='b'>long</span>, <span class='b'>long</span> <span class='b'>long</span>, <span class='b'>long</span> <span class='b'>long</span>&gt;&gt; get_Availability();

  <span class='b'>bool</span> in_Unit_price(<span class='k'>const</span> char *, <span class='k'>const</span> char *, <span class='k'>const</span> char *);
  std::vector&lt;std::tuple&lt;<span class='b'>long</span> <span class='b'>long</span>, <span class='b'>long</span> <span class='b'>long</span>, <span class='b'>long</span> <span class='b'>long</span>&gt;&gt; get_Unit_price();

  std::unique_ptr&lt;cell::<span class='m'>Value</span>&gt; call_Lowest_price_suppliers();
  std::vector&lt;<span class='b'>long</span> <span class='b'>long</span>&gt; call_Lowest_price_suppliers(<span class='k'>const</span> char *);

<span class='b'>private:</span>
  <span class='b'>void</span> *ptr;
};
</code></pre></section></figure>
</p>

<p>The first three methods of the <code class="inline-code-box"><span class="inline-code">Supply</span></code> class, <code class="inline-code-box"><span class="inline-code">read_state()</span></code>, <code class="inline-code-box"><span class="inline-code">set_state(..)</span></code> and <code class="inline-code-box"><span class="inline-code">execute(..)</span></code>, are the same as before. The next two, <code class="inline-code-box"><span class="inline-code">get_Next_part_id()</span></code> and <code class="inline-code-box"><span class="inline-code">get_Next_supplier_id()</span></code>, are just accessors for the corresponding member variables, just like <code class="inline-code-box"><span class="inline-code">get_Value()</span></code> and <code class="inline-code-box"><span class="inline-code">get_Updates()</span></code> in <code class="inline-code-box"><span class="inline-code">Counter</span></code>. All the other methods are new, and are either accessor for some mutable relation variable or a wrapper for a Cell method. A first set of methods, of the form <code class="inline-code-box"><span class="inline-code">bool in_*(..)</span></code>, checks whether a relation contains a given tuple (or value, for unary relations):</p>

<p><figure class="highlight"><section><pre><code><span class='c'>// Checks whether the <span class="inline-code">part</span> unary relation</span>
<span class='c'>// contains the value <span class="inline-code">part_id(1)</span></span>
supply_instance.in_Part(<span class='s'>"part_id(1)"</span>)

<span class='c'>// Checks whether the <span class="inline-code">sells</span> binary relation contains</span>
<span class='c'>// the pair <span class="inline-code">supplier_id(8)</span>, <span class="inline-code">part_id(2)</span></span>
supply_instance.in_Sells(<span class='s'>"supplier_id(8)"</span>, <span class='s'>"part_id(2)"</span>)

<span class='c'>// Checks whether <span class="inline-code">availability</span> contains the</span>
<span class='c'>// triple <span class="inline-code">supplier_id(7)</span>, <span class="inline-code">part_id(3)</span>, <span class="inline-code">25</span></span>
supply_instance.in_Availability(<span class='s'>"supplier_id(7)"</span>, <span class='s'>"part_id(3)"</span>, <span class='n'>25</span>)
</code></pre></section></figure>
</p>

<p>A second group of methods, like <code class="inline-code-box"><span class="inline-code">get_Supplier()</span></code> or <code class="inline-code-box"><span class="inline-code">get_Unit_price()</span></code>, return the entire content of a given relations, as a <code class="inline-code-box"><span class="inline-code">vector&lt;tuple&lt;..&gt;&gt;</span></code> (or just <code class="inline-code-box"><span class="inline-code">vector&lt;..&gt;</span></code> in the case of unary relations).</p>

<p>Binary relations with a key on the first column (that is, maps) also have accessors that return the value corresponding to a given key, provided that the relation/map contains such key, and returns a boolean value that indicates whether the lookup was successful:</p>

<p><figure class="highlight">
<section>
<pre><code><span class='c'>// Looks up the name of the supplier identified by</span>
<span class='c'>// the value <span class="inline-code">supplier_id(21)</span> and stores it in</span>
<span class='c'>// the variable <span class="inline-code">name</span>, if such a supplier actually exists.</span>
<span class='c'>// Returns true if the supplier was found and the lookup</span>
<span class='c'>// was successful, false otherwise</span>
string name;
bool found = lookup_Name(<span class='s'>"supplier_id(21)"</span>, name);
</code></pre>
</section>
</figure>
</p>

<p>The last group of methods (<code class="inline-code-box"><span class="inline-code">call_Lowest_price_suppliers(..)</span></code>) are just the compiled C++ version of the corresponding Cell methods of the <code class="inline-code-box"><span class="inline-code">Supply</span></code> automaton.</p>


<h3>Reactive automata</h3>

<p>We'll use <code class="inline-code-box"><span class="inline-code">Switch</span></code> automaton as our first example. This is the interface of the corresponding generated class:</p>

<p><figure class="highlight"><section><pre style="margin: 0; line-height: 125%"><code><span class='k'>namespace</span> generated {
  <span class='k'>class</span> <span class='m'>Switch</span> {
  <span class='b'>public:</span>
    <span class='k'>enum</span> <span class='m'>Input</span> {<span class='u'>SWITCH_ON</span>, <span class='u'>SWITCH_OFF</span>};

    <span class='k'>enum</span> <span class='m'>Output</span> {<span class='u'>IS_ON</span>};

    Switch();
    ~Switch();

    <span class='b'>void</span> set_input(<span class='m'>Input</span> input, <span class='k'>const</span> <span class='b'>char</span> *value);
    <span class='b'>void</span> read_output(<span class='m'>Output</span> output, <span class='b'>char</span> *buffer, <span class='b'>unsigned</span> <span class='b'>int</span> size);

    <span class='b'>void</span> apply();

    std::<span class='b'>unique_ptr</span>&lt;cell::<span class='m'>Value</span>&gt; read_state();
    <span class='b'>void</span> set_state(<span class='k'>const</span> <span class='b'>char</span> *buffer);

    <span class='b'>unsigned</span> <span class='b'>int</span> changed_outputs_count();
    <span class='m'>Output</span> changed_output_id(<span class='b'>unsigned</span> <span class='b'>int</span> idx);

    <span class='b'>void</span> set_Switch_on(<span class='b'>bool</span>);
    <span class='b'>void</span> set_Switch_off(<span class='b'>bool</span>);

    <span class='b'>bool</span> get_Is_on();

  <span class='b'>private:</span>
    <span class='b'>void</span> *ptr;
  };
}
</code></pre></section></figure>
</p>

<p>The first thing to note here is the two enumerations <code class="inline-code-box"><span class="inline-code">Input</span></code> and <code class="inline-code-box"><span class="inline-code">Output</span></code>, whose elements are the uppercase version of the names of the inputs and outputs of <code class="inline-code-box"><span class="inline-code">Switch</span></code>. These are used in conjunction with the methods <code class="inline-code-box"><span class="inline-code">set_input()</span></code> and <code class="inline-code-box"><span class="inline-code">read_output()</span></code> as shown here:</p>

<p><figure class="highlight">
<section>
<pre><code><span class='c'>// Setting the value of the two inputs</span>
switch.set_input(<span class='m'>Switch</span>::<span class='u'>SWITCH_ON</span>, <span class='s'>"true"</span>);
switch.set_input(<span class='m'>Switch</span>::<span class='u'>SWITCH_OFF</span>, <span class='s'>"false"</span>);

<span class='c'>// Propagating the changes to the inputs</span>
<span class='c'>// throughout the automaton instance</span>
switch.apply();

<span class='c'>// Reading and printing the value of the only output</span>
<span class='b'>char</span> text[<span class='n'>16</span>];
switch.read_output(<span class='m'>Switch</span>::<span class='u'>IS_ON</span>, text, <span class='n'>16</span>);
printf(<span class='s'>"is_on = %s\n"</span>, text);
</code></pre></section></figure>
</p>

<p>As an alternative to <code class="inline-code-box"><span class="inline-code">set_input(..)</span></code> and <code class="inline-code-box"><span class="inline-code">read_output(..)</span></code>, which can operate on any input or output and use the textual representation of values as an exchange format, the generated class also provides another set of methods each of which can manipulate a single input or output, but that are more convenient to use in most cases. The above code snippet can be rewritten as follow:</p>

<p><figure class="highlight">
<section>
<pre><code><span class='c'>// Setting the value of the two inputs</span>
switch.set_Switch_on(<span class='k'>true</span>);
switch.set_Switch_off(<span class='k'>false</span>);

<span class='c'>// Propagating the changes to the inputs</span>
<span class='c'>// throughout the automaton instance</span>
switch.apply();

<span class='c'>// Reading and printing the value of the only output</span>
<span class='b'>bool</span> is_on = switch.get_Is_on();
printf(<span class='s'>"is_on = %s\n"</span>, is_on ? <span class='s'>"true"</span> : <span class='s'>"false"</span>);
</code></pre></section></figure>
</p>

<p>The <code class="inline-code-box"><span class="inline-code">read_state()</span></code> and <code class="inline-code-box"><span class="inline-code">set_state(..)</span></code> methods work in the same way as with static automata, but with the limitations we've already discussed for time-aware automata. The last two methods, <code class="inline-code-box"><span class="inline-code">changed_outputs_count()</span></code> and <code class="inline-code-box"><span class="inline-code">changed_output_id(..)</span></code> provide you with a list of outputs that have changed (or have been active, in the case of discrete outputs) as a result of the last call to <code class="inline-code-box"><span class="inline-code">apply()</span></code>:</p>

<figure class="highlight">
<section>
<pre><code><span class='c'>// Changing inputs here</span>
...

<span class='c'>// Propagating those changes</span>
switch.<span class='k'>apply</span>();

<span class='c'>// Iterating through the outputs that have changed</span>
<span class='c'>// if countinuous or have been activated if discrete</span>
int count = switch.changed_outputs_count();
<span class='k'>for</span> (int i=<span class='n'>0</span> ; i &lt; count ; i++) {
  <span class='c'>// Retrieving the id of the i-th output that</span>
  <span class='c'>// has changed or activated</span>
  <span class='m'>Switch</span>::<span class='m'>Output</span> id = switch.changed_output_id(i);

  <span class='c'>// Reading the value of the changed output</span>
  char buffer[<span class='n'>256</span>];
  switch.read_output(id, buffer, <span class='n'>256</span>);

  <span class='c'>// Now time to do something with the value of the output</span>
  ...
}
</section>
</figure>
</code></pre>

<p>The last thing we need to see is how to deal with time-aware automata. We'll use <code class="inline-code-box"><span class="inline-code">WaterSensor</span></code>:</p>

<p><figure class="highlight"><section><pre style="margin: 0; line-height: 125%"><code><span class='k'>namespace</span> generated {
  <span class='k'>class</span> <span class='m'>WaterSensor</span> {
  <span class='b'>public:</span>
    <span class='k'>enum</span> <span class='m'>Input</span> {<span class='u'>RAW_READING</span>};

    <span class='k'>enum</span> <span class='m'>Output</span> {<span class='u'>SENSOR_STATE</span>};

    WaterSensor();
    ~WaterSensor();

    <span class='b'>void</span> set_input(<span class='m'>Input</span> input, <span class='k'>const</span> <span class='b'>char</span> *value);
    <span class='b'>void</span> read_output(<span class='m'>Output</span> output, <span class='b'>char</span> *buffer, <span class='b'>unsigned</span> <span class='b'>int</span> size);

    <span class='b'>void</span> set_elapsed_millisecs(<span class='b'>unsigned</span> <span class='b'>long</span> <span class='b'>long</span> time);
    <span class='b'>void</span> set_elapsed_secs(<span class='b'>unsigned</span> <span class='b'>long</span> <span class='b'>long</span> time);

    <span class='b'>bool</span> apply();

    std::unique_ptr&lt;cell::<span class='m'>Value</span>&gt; read_state();
    <span class='b'>void</span> set_state(<span class='k'>const</span> <span class='b'>char</span> *buffer);

    <span class='b'>unsigned</span> <span class='b'>int</span> changed_outputs_count();
    <span class='m'>Output</span> changed_output_id(<span class='b'>unsigned</span> <span class='b'>int</span> idx);

    std::unique_ptr&lt;cell::<span class='m'>Value</span>&gt; get_Sensor_state();

  <span class='b'>private:</span>
    <span class='b'>void</span> *ptr;
  };
</code></pre></section></figure>
</p>

<p>The only differences here, apart from the input setters and output getters which are obviously specific to each automaton type, are the two extra methods <code class="inline-code-box"><span class="inline-code">set_elapsed_secs(..)</span></code> and <code class="inline-code-box"><span class="inline-code">set_elapsed_millisecs(..)</span></code> and the fact that <code class="inline-code-box"><span class="inline-code">apply()</span></code> now returns a boolean value. The former are the equivalent of the <code class="inline-code-box"><span class="inline-code">elapsed</span></code> instruction in Cell, and the value now returned by <code class="inline-code-box"><span class="inline-code">apply()</span></code> has the same meaning as the one returned by the <code class="inline-code-box"><span class="inline-code">apply</span></code> instruction in a Cell procedure. Here's an example of how to update an instance of <code class="inline-code-box"><span class="inline-code">WaterSensor</span></code>:</p>

<p><figure class="highlight"><section><pre><code><span class='c'>// Updating the values of the inputs here</span>
...

<span class='c'>// Setting the amount of time that has elapsed</span>
<span class='c'>// since the last call to <span class="inline-code">water_sensor.apply()</span></span>
water_sensor.set_elapsed_millisecs(<span class='n'>100</span>);

<span class='k'>do</span> {
  <span class='c'>// Repeatedly calling <span class="inline-code">apply()</span> until it returns true</span>
  <span class='c'>// That happens only once all pending timers have</span>
  <span class='c'>// been processed and the changes in the values of</span>
  <span class='c'>// the inputs propagated throughout the automaton</span>
  <span class='b'>bool</span> done = water_sensor.apply();

  <span class='c'>// Iterating through the outputs that have changed</span>
  <span class='c'>// if countinuous or have been activated if discrete</span>
  <span class='b'>int</span> count = water_sensor.changed_outputs_count();
  <span class='k'>for</span> (<span class='b'>int</span> i=<span class='n'>0</span> ; i &lt; count ; i++) {
    <span class='c'>// Retrieving the id of the i-th output that</span>
    <span class='c'>// has changed or activated</span>
    <span class='m'>WaterSensor</span>::<span class='m'>Output</span> id = water_sensor.changed_output_id(i);

    <span class='c'>// Reading the value of the changed output</span>
    <span class='b'>char</span> buffer[<span class='n'>64</span>];
    water_sensor.read_output(id, buffer, <span class='n'>64</span>);

    <span class='c'>// Now time to do something with the value of the output</span>
    ...
  }
} <span class='k'>while</span> (!done);
</code></pre></section></figure>
</p>


        </article>
      </div>

      <aside id="sidebar">
        <div id='pages'>
          <ul class='toc'>
            <li>Start Here
              <ul class="toc">
                <li><a href='index.html'>Home</a></li>
                <li><a href='overview.html'>Overview</a></li>
              </ul>
            </li>
            <li>The Basics
              <ul class="toc">
                <li><a href='data.html'>Data</a></li>
                <li><a href='types.html'>Types</a></li>
                <li><a href='functions.html'>Functions</a></li>
                <li><a href='imperative.html'>Imperative code</a></li>
                <li><a href='procedures.html'>Procedures</a></li>
                <li><a href='typechecking.html'>Type checking</a></li>
                <li><a href='miscellanea.html'>Protocols, implicit arguments and memoization</a></li>
              </ul>
            </li>
            <li>Automata
              <ul class="toc">
                <li><a href='static.html'>Static automata</a></li>
                <li><a href='updates.html'>State updates</a></li>
                <li><a href='reactive.html'>Reactive automata</a></li>
                <li><a href='commands.html'>Using automata</a></li>
                <li><a href='interface.html'>Interfacing with C++</a></li>
              </ul>
            </li>

<!--             <li>Rationale
              <ul class="toc">
                <li><a href='state.html'>State</a></li>
                <li><a href='functional.html'>Functional programming</a></li>
                <li><a href='integrity.html'>Encapsulation, equality and data integrity</a></li>
              </ul>
            </li>
 -->
            <li>Miscellanea
              <ul class="toc">
                <li><a href='getting-started.html'>Getting started</a></li>
                <!-- <li><a href='community.html'>Community and contacts</a></li> -->
              </ul>
            </li>

          </ul>
        </div>
      </aside>
    </div>
  </div>
</body>
</html>
