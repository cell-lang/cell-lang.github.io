<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta content="width=device-width,initial-scale=1" name="viewport">
  <meta name="description" content="The Cell Programming Language">

  <title>The Cell Programming Language</title>

  <link href="./fonts.css" rel="stylesheet" type="text/css" media="screen">
  <link href="./main.css" rel="stylesheet">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113669835-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113669835-1');
  </script>

</head>

<body>
  <div id="container">

    <header id="topbar">
    </header>

    <div id="main-container">
      <div id="main">
        <article class="content">
<h2>Benchmarks</h2>

<p>The benchmarks we'll be examining in this chapter are meant to test the performance of code that updates and queries the state of relational automata, and compare it to equivalent hand-written Java or C# code (Benchmarks that test the functional subset of the language for purely computational tasks are available <a href='benchmarks-functional.html'>here</a>). The code generated by the Cell compiler is very close, in terms of performance, to equivalent, hand-written object-oriented code, and in some cases even outperforms it.</p>

<p>Compared to garbage-collected, object-oriented languages like Java or C#, Cell has a number of both structural advantages and disadvantages in terms of performance. One major disadvantage is the deferred update model of relational automata: when an instruction that updates a member or mutable relation variable is executed, the update is not applied immediately, but stored in temporary memory until the message handler returns, which obviously involves a certain amount of overhead. A separate but related source of overhead is support for transactions. Another disadvantage is that in Cell, you can (and usually will) specify a set of integrity constraints (that is, keys and foreign keys) on the state of relational automata that need to be checked at runtime.  A static analysis of the codebase can remove some of this overhead, but not all of it all the time. A more general problem is that mutability in Cell is subject to a number of restrictions that are bound to negatively affect performance in at least some situations.</p>

<p>On the other hand, relational automata naturally lend themselves to being implemented using techniques borrowed from the Entity/Component architecture and more generally from data-oriented design. One advantage of these architectures is that they vastly reduce the number of cache misses by improving the locality of the data. As we'll see later, they also seem to put less strain on the garbage collector, which is not suprising: having, say, a million instances of a class with five member variables in OOP means having a million distinct blocks of memory to keep track of, but with the E/C architecture you would end up with five arrays of one million elements each plus a hashtable (another array), which are much easier for the garbage collector to deal with.</p>

<p>While the code generated by the Cell compiler is already pretty fast, remember that optimization is still a work in progress: there's a lot left to do and, presumably, at least some margin for improvement. Among other things, the data structures used to implement ternary relations, while reasonably fast, are still too generic and don't take advantage of the specific usage of each individual relation variable and the constraints that are placed on it; many-to-many binary relations seem to have performance problems under deletion that haven't been investigated yet; the generated code still performs many useless integrity checks that could be eliminated by a more sophisticated static analysis; sending a message to an automaton currently involves more overhead that a method call in an imperative language, but in many cases that overhead could be eliminated; and several of the optimizations the compiler already performs would be more effective if combined with aggressive inlining of methods. The effects of these shortcomings are clearly visible in the example we will be examining.</p>

<p>The other thing to consider is that compiling to Java or C# (or any other garbage-collected, memory-safe language I know) is far from being ideal. Only compiling to C/C++ could fully take advantage, in terms of performance, of Cell's unique design, but a C/C++ code generator is not yet available.</p>


<h3>The IMDB movie database</h3>

<p>This example will make use of a a subset of the data in the IMDB movie database. The dataset is contained in a number of CSV files of moderate size (~140 MB in total). The various versions of the code will parse and load the dataset into memory, run a number of queries on it and finally update it in various ways. Both the code and the dataset are available on <a href='https://github.com/cell-lang/example-imdb/'>github</a> (the relevant files are <a href='https://github.com/cell-lang/example-imdb/blob/master/cell/main.cell'>main.cell</a> and <a href='https://github.com/cell-lang/example-imdb/blob/master/cell/imdb.cell'>imdb.cell</a> for Cell, <a href='https://github.com/cell-lang/example-imdb/blob/master/java/imdb.java'>imdb.java</a> for Java and <a href='https://github.com/cell-lang/example-imdb/blob/master/csharp/imdb.cs'>imdb.cs</a> for C#). If you have any questions or comments or if there's anything you would like to see added to this set of benchmarks, just leave a message in the <a href='https://groups.google.com/d/forum/cell-lang'>forum</a>.</p>

<p>All tests were run on a dual-core Intel Celeron 1005M running Lubuntu Linux 18.10, using either the Java HotSpot Server VM (version 12.0.1) or the .NET Core SDK (version 2.2.301). We will examine the single-core results first, since all versions of the code are single-threaded, and discuss dual-core performance later.</p>

<p>Each test was run 25 times, but the first 5 iteractions were discarded, so as to give the JVM/CLR time to warm up, and the remaining 20 were averaged. Cell took longer than Java to warm up (it's just more code) and C# took barely any time at all.</p>

<p>Here's the visual representation of the structure of input dataset:</p>

<p><div><img src='imdb.svg' style='width:100%'></div></p>

<p>and this is the definition of the relational automaton we'll be using to store it:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>schema</span> <span class='m'>MoviesDB</span> {
  actor(<span class='m'>Actor</span>)
    first_name  : <span class='m'>String</span>,
    last_name   : <span class='m'>String</span>,
    gender      : <span class='m'>Gender</span>;

  movie(<span class='m'>Movie</span>)
    name    : <span class='m'>String</span>,
    year    : <span class='m'>Int</span>,
    rank    : <span class='m'>Float</span>,
    genre*  : <span class='m'>Genre</span>;

  director(<span class='m'>Director</span>)
    director_first_name : <span class='m'>String</span>,
    director_last_name  : <span class='m'>String</span>;

  acted_in(<span class='m'>Actor</span>, <span class='m'>Movie</span>)
    role* : <span class='m'>String</span>;

  directed(<span class='m'>Director</span>, <span class='m'>Movie</span>);

  acted_in(a, m) -&gt; actor(a), movie(m);
  directed(d, m) -&gt; director(d), movie(m);

  <span class='c'>// More stuff here</span>
  ...
}
</section>
</figure>
</code></pre>


<h3>Loading the dataset</h3>

<p>The first test consists of parsing each of the CSV files and inserting the data into the corresponding relation variables in the case of Cell, or creating and wiring the corresponding set of objects for Java and C#. The results are show in the following table (all times are in milliseconds):</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell/Java</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>Cell/C#</th>
    <th class='number-header'>C#</th>
  </tr>
  <tr>
    <td>movies.csv</td>
    <td class='number'>343</td>
    <td class='number'>294</td>
    <td class='number'>1357</td>
    <td class='number'>1047</td>
  </tr>
  <tr>
    <td>actors.csv</td>
    <td class='number'>1964</td>
    <td class='number'>2478</td>
    <td class='number'>3705</td>
    <td class='number'>3994</td>
  </tr>
  <tr>
    <td>directors.csv</td>
    <td class='number'>74</td>
    <td class='number'>98</td>
    <td class='number'>402</td>
    <td class='number'>92</td>
  </tr>
  <tr>
    <td>movies_directors.csv</td>
    <td class='number'>238</td>
    <td class='number'>208</td>
    <td class='number'>437</td>
    <td class='number'>369</td>
  </tr>
  <tr>
    <td>movies_genres.csv</td>
    <td class='number'>246</td>
    <td class='number'>126</td>
    <td class='number'>450</td>
    <td class='number'>511</td>
  </tr>
  <tr>
    <td>roles.csv</td>
    <td class='number'>7489</td>
    <td class='number'>5096</td>
    <td class='number'>12826</td>
    <td class='number'>9150</td>
  </tr>
  <tr>
    <td>Total</td>
    <td class='number'>10354</td>
    <td class='number'>8300</td>
    <td class='number'>19177</td>
    <td class='number'>15163</td>
  </tr>
</table>
</p>

<p>The second and forth columns show the loading times for Java and C# respectively, while the first and third ones show the loading times for Cell when compiling to Java and C# respectively. Each row correspond to a different CSV file, save for the last one which shows the totals. The next table shows the same results normalized:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell/Java</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>Cell/C#</th>
    <th class='number-header'>C#</th>
  </tr>
  <tr>
    <td>movies.csv</td>
    <td class='number'>1.17</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>4.62</td>
    <td class='number'>3.56</td>
  </tr>
  <tr>
    <td>actors.csv</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.26</td>
    <td class='number'>1.89</td>
    <td class='number'>2.03</td>
  </tr>
  <tr>
    <td>directors.csv</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.32</td>
    <td class='number'>5.43</td>
    <td class='number'>1.24</td>
  </tr>
  <tr>
    <td>movies_directors.csv</td>
    <td class='number'>1.14</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.10</td>
    <td class='number'>1.77</td>
  </tr>
  <tr>
    <td>movies_genres.csv</td>
    <td class='number'>1.95</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>3.57</td>
    <td class='number'>4.06</td>
  </tr>
  <tr>
    <td>roles.csv</td>
    <td class='number'>1.47</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.52</td>
    <td class='number'>1.80</td>
  </tr>
  <tr>
    <td>Total</td>
    <td class='number'>1.25</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.31</td>
    <td class='number'>1.83</td>
  </tr>
</table>
</p>

<p>For each row the times are scaled so that the best one becames 1.0. As you can see Java is generally the fastest of the bunch, followed by Cell compiled to Java, then C# and finally Cell compiled to C#.</p>

<p>Note that the individual numbers in the above tables are not particularly reliable (only the totals are), because a lot depends on when the garbage collector decides to kick in, which varies depending on how the tests are set up. Since this phase of the test is dominated by object creation, which puts a lot of pressure on the garbage collector, it's actually interesting to see what the numbers would be in an "infinite memory" scenario, which can be approximated by setting (with the <code class='inline-code-box'><span class='inline-code'>-Xms</span></code> and <code class='inline-code-box'><span class='inline-code'>-Xmx</span></code> options) the amount of memory available to the JVM to a sufficiently large amount, and by explicitly invoking the garbage collector before loading each individual file (obviously, the times spent doing the preventive garbage collection is not included in the figures shown here):</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell/Java</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>Ratio</th>
  </tr>
  <tr>
    <td>movies.csv</td>
    <td class='number'>297</td>
    <td class='number'>136</td>
    <td class='number'>2.18</td>
  </tr>
  <tr>
    <td>actors.csv</td>
    <td class='number'>1659</td>
    <td class='number'>1102</td>
    <td class='number'>1.50</td>
  </tr>
  <tr>
    <td>directors.csv</td>
    <td class='number'>51</td>
    <td class='number'>26</td>
    <td class='number'>1.96</td>
  </tr>
  <tr>
    <td>movies_directors.csv</td>
    <td class='number'>227</td>
    <td class='number'>141</td>
    <td class='number'>1.60</td>
  </tr>
  <tr>
    <td>movies_genres.csv</td>
    <td class='number'>184</td>
    <td class='number'>81</td>
    <td class='number'>2.27</td>
  </tr>
  <tr>
    <td>roles.csv</td>
    <td class='number'>7857</td>
    <td class='number'>2247</td>
    <td class='number'>3.49</td>
  </tr>
  <tr>
    <td>Total</td>
    <td class='number'>10275</td>
    <td class='number'>3733</td>
    <td class='number'>2.75</td>
  </tr>
</table>
</p>

<p>As you can see, with the garbage collector out of the way, Java is consistently and significantly faster than Cell, which is not particularly surprising: object creation is extremely fast in Java, while the data structures used by Cell are more complex, and updates are also slowed down by a number of factors (transactions, integrity checks, etc.) mentioned in the introduction. But much of that advantage is then lost by overloading the garbage collector.</p>

<p>This also shows where Cell lags the most compared to Java: loading the data in <code class='inline-code-box'><span class='inline-code'>roles.csv</span></code>. The vast majority of that time is spent updating the <code class='inline-code-box'><span class='inline-code'>role</span></code> ternary relation. As already explained in the introduction, optimization of ternary relations is still a work in progress. Fixing that should be enough to close most of the performance gap between Cell and Java in this particular test.</p>


<h3>Updating the dataset</h3>

<p>We'll now be performing a number of update operation, that are described here:</p>

<ul><li>U1: Increments the rank of all movies released before a given year by a specified amount.</li><li>U2: For each actor, computes the average rank of the movies they appear in, and stores the result in the <code class='inline-code-box'><span class='inline-code'>actor_rank</span></code> relation variable or in the <code class='inline-code-box'><span class='inline-code'>avgMoviesRank</span></code> member variable.</li><li>U3: For each director, computes the average rank of the movies they directed, and stores the result in the <code class='inline-code-box'><span class='inline-code'>director_rank</span></code> relation variable or in the <code class='inline-code-box'><span class='inline-code'>avgMoviesRank</span></code> member variable.</li><li>U4: Randomly generates a list of movie ids, and for each of them increments their rank and updates the rank of all actors and directors that worked on it.</li><li>U5: Deletes all movies below a given rank.</li><li>U6: Deletes all actors that do not appear in at least one of the remaining movies.</li><li>U7: Deletes all directors that did not work on any of the remaining movies.</li></ul>

<p>The results are shown here:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell/Java</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>Cell/C#</th>
    <th class='number-header'>C#</th>
  </tr>

  <tr>
    <td>U1</td>
    <td class='number'>43</td>
    <td class='number'>36</td>
    <td class='number'>96</td>
    <td class='number'>45</td>
  </tr>
  <tr>
    <td>U2</td>
    <td class='number'>228</td>
    <td class='number'>228</td>
    <td class='number'>407</td>
    <td class='number'>361</td>
  </tr>
  <tr>
    <td>U3</td>
    <td class='number'>24</td>
    <td class='number'>26</td>
    <td class='number'>44</td>
    <td class='number'>29</td>
  </tr>
  <tr>
    <td>U4</td>
    <td class='number'>190</td>
    <td class='number'>348</td>
    <td class='number'>320</td>
    <td class='number'>351</td>
  </tr>
  <tr>
    <td>U5</td>
    <td class='number'>1887</td>
    <td class='number'>1224</td>
    <td class='number'>1991</td>
    <td class='number'>1899</td>
  </tr>
  <tr>
    <td>U6</td>
    <td class='number'>209</td>
    <td class='number'>70</td>
    <td class='number'>289</td>
    <td class='number'>66</td>
  </tr>
  <tr>
    <td>U7</td>
    <td class='number'>7</td>
    <td class='number'>11</td>
    <td class='number'>12</td>
    <td class='number'>7</td>
  </tr>
</table>

<!--
[47, 256, 25, 262, 2717, 201, 7]
[36, 228, 26, 348, 1224, 70, 11]
[45, 361, 29, 351, 1899, 66, 7]

[1.3, 1.12, 0.96, 0.75, 2.21, 2.87, 0.63]
[1.04, 0.7, 0.86, 0.74, 1.43, 3.04, 1.0]
3515 1943 2758
1.8 1.27
 --></p>

<p>and here are the normalized ones:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell/Java</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>Cell/C#</th>
    <th class='number-header'>C#</th>
  </tr>

  <tr>
    <td>U1</td>
    <td class='number'>1.19</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.67</td>
    <td class='number'>1.25</td>
  </tr>
  <tr>
    <td>U2</td>
    <td class='highlighted-number'>1.00</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.79</td>
    <td class='number'>1.58</td>
  </tr>
  <tr>
    <td>U3</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.08</td>
    <td class='number'>1.83</td>
    <td class='number'>1.21</td>
  </tr>
  <tr>
    <td>U4</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.83</td>
    <td class='number'>1.68</td>
    <td class='number'>1.85</td>
  </tr>
  <tr>
    <td>U5</td>
    <td class='number'>1.54</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.63</td>
    <td class='number'>1.55</td>
  </tr>
  <tr>
    <td>U6</td>
    <td class='number'>3.17</td>
    <td class='number'>1.06</td>
    <td class='number'>4.38</td>
    <td class='highlighted-number'>1.00</td>
  </tr>
  <tr>
    <td>U7</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.57</td>
    <td class='number'>1.71</td>
    <td class='highlighted-number'>1.00</td>
  </tr>
</table>
</p>

<p>As you can see, the speed of the code generated by the Cell compiler is generally similar to that of handwritten code in the same language, the most notable exception being update <code class='inline-code-box'><span class='inline-code'>U6</span></code>.</p>


<h3>Queries</h3>

<p>Let's now compare the performance of computation that does not update the dataset. We'll be running the following set of queries:</p>

<ul><li>Q1: Counting the number of movies whose rank is no less that a given threshold. Repeated for several different values of the threshold.</li><li>Q2: Counting the number of actors who played in at least one movie whose rank was no less than a given threshold. Repeated for several different values of the threshold.</li><li>Q3: For each actor, finding all co-actors in movies with a given minimum rank.</li><li>Q4: Calculating a histogram of movie ages.</li><li>Q5: Calculating the average age of all movies with a given minimum rank.</li><li>Q6: Calculating the sum of the ages of all movies in the dataset.</li><li>Q7: For each movie in a randomly generated set, finding all movies that have actors in common with it.</li><li>Q8: For each actor in a randomly generated set, retrieving the last names of all actors with the same first name. Duplicates are eliminated.</li><li>Q9: Same as Q3, but also returning the number of movies they appeared in together.</li><li>Q10: Same as Q8, but duplicates are not eliminated.</li><li>Q11: For each director, checking if they ever also worked as actors.</li><li>Q12: For each actor, computing the full name by concatenating first and last names.</li></ul>

<p>Some of the queries are a bit bizarre, but they actually manage to test all the basic operations on relations: attribute lookups, navigation, searches and linear scans. The results are shown here in milliseconds:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell/Java</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>Cell/C#</th>
    <th class='number-header'>C#</th>
  </tr>

  <tr>
    <td>Q1</td>
    <td class='number'>222</td>
    <td class='number'>438</td>
    <td class='number'>527</td>
    <td class='number'>1142</td>
  </tr>
  <tr>
    <td>Q2</td>
    <td class='number'>4896</td>
    <td class='number'>9328</td>
    <td class='number'>8388</td>
    <td class='number'>10174</td>
  </tr>
  <tr>
    <td>Q3</td>
    <td class='number'>4859</td>
    <td class='number'>6135</td>
    <td class='number'>8047</td>
    <td class='number'>10191</td>
  </tr>
  <tr>
    <td>Q4</td>
    <td class='number'>203</td>
    <td class='number'>237</td>
    <td class='number'>374</td>
    <td class='number'>530</td>
  </tr>
  <tr>
    <td>Q5</td>
    <td class='number'>172</td>
    <td class='number'>235</td>
    <td class='number'>424</td>
    <td class='number'>526</td>
  </tr>
  <tr>
    <td>Q6</td>
    <td class='number'>531</td>
    <td class='number'>807</td>
    <td class='number'>1685</td>
    <td class='number'>1972</td>
  </tr>
  <tr>
    <td>Q7</td>
    <td class='number'>3693</td>
    <td class='number'>4131</td>
    <td class='number'>6498</td>
    <td class='number'>4877</td>
  </tr>
  <tr>
    <td>Q8</td>
    <td class='number'>4946</td>
    <td class='number'>3945</td>
    <td class='number'>8838</td>
    <td class='number'>5049</td>
  </tr>
  <tr>
    <td>Q9</td>
    <td class='number'>3519</td>
    <td class='number'>1663</td>
    <td class='number'>6965</td>
    <td class='number'>3119</td>
  </tr>
  <tr>
    <td>Q10</td>
    <td class='number'>4004</td>
    <td class='number'>2386</td>
    <td class='number'>14417</td>
    <td class='number'>3071</td>
  </tr>
  <tr>
    <td>Q11</td>
    <td class='number'>344</td>
    <td class='number'>282</td>
    <td class='number'>483</td>
    <td class='number'>159</td>
  </tr>
  <tr>
    <td>Q12</td>
    <td class='number'>530</td>
    <td class='number'>220</td>
    <td class='number'>855</td>
    <td class='number'>94</td>
  </tr>
</table>
</p>

<p>and here is the normalized version:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell/Java</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>Cell/C#</th>
    <th class='number-header'>C#</th>
  </tr>

  <tr>
    <td>Q1</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.97</td>
    <td class='number'>2.37</td>
    <td class='number'>5.14</td>
  </tr>
  <tr>
    <td>Q2</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.91</td>
    <td class='number'>1.71</td>
    <td class='number'>2.08</td>
  </tr>
  <tr>
    <td>Q3</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.26</td>
    <td class='number'>1.66</td>
    <td class='number'>2.10</td>
  </tr>
  <tr>
    <td>Q4</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.17</td>
    <td class='number'>1.84</td>
    <td class='number'>2.61</td>
  </tr>
  <tr>
    <td>Q5</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.37</td>
    <td class='number'>2.47</td>
    <td class='number'>3.06</td>
  </tr>
  <tr>
    <td>Q6</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.52</td>
    <td class='number'>3.17</td>
    <td class='number'>3.71</td>
  </tr>
  <tr>
    <td>Q7</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.12</td>
    <td class='number'>1.76</td>
    <td class='number'>1.32</td>
  </tr>
  <tr>
    <td>Q8</td>
    <td class='number'>1.25</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.24</td>
    <td class='number'>1.28</td>
  </tr>
  <tr>
    <td>Q9</td>
    <td class='number'>2.12</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>4.19</td>
    <td class='number'>1.88</td>
  </tr>
  <tr>
    <td>Q10</td>
    <td class='number'>1.68</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>6.04</td>
    <td class='number'>1.29</td>
  </tr>
  <tr>
    <td>Q11</td>
    <td class='number'>2.16</td>
    <td class='number'>1.77</td>
    <td class='number'>3.04</td>
    <td class='highlighted-number'>1.00</td>
  </tr>
  <tr>
    <td>Q12</td>
    <td class='number'>5.64</td>
    <td class='number'>2.34</td>
    <td class='number'>9.10</td>
    <td class='highlighted-number'>1.00</td>
  </tr>
</table>
</p>

<p>When compiling to Java Cell is significantly slower than equivalent Java code only for queries <code class='inline-code-box'><span class='inline-code'>Q9</span></code>, <code class='inline-code-box'><span class='inline-code'>Q10</span></code> and <code class='inline-code-box'><span class='inline-code'>Q12</span></code>. Let's take a look at each of them in turn. <code class='inline-code-box'><span class='inline-code'>Q9</span></code> makes use of a map/dictionary which is repeatedly mutated. In Cell maps only support functional updates, which are reasonably fast, but cannot compete with Java's mutable, hashtable-based maps. In <code class='inline-code-box'><span class='inline-code'>Q10</span></code>, an optimization made by the Cell compiler clashes with the limitation of Java's object model. The same problem would not present itself when compiling to C/C++. In this specific case though, it could be solved with a more sophisticated analysis of the source code. <code class='inline-code-box'><span class='inline-code'>Q12</span></code> is a special case: the cause of the bad performance is just a weird problem with string concatenation, that will be fixed soon.</p>

<p>When compiling to C# the generated code is noticeably slower than equivalent handwritten C# code also for <code class='inline-code-box'><span class='inline-code'>Q8</span></code> and <code class='inline-code-box'><span class='inline-code'>Q11</span></code>, but the reasons for that haven't been properly investigated yet.</p>


<h3>Embedded mode</h3>

<p>Cell is primarily meant to be used as an embedded language, so we'll now take a look at its performance for that specific use case. As one might expect, the generated code can sometimes be slower in embedded mode, because of all the data conversion and validation that takes place at the boundary between handwritten and generated code.</p>

<p>The performance hit varies considerably, and it's impossible to quantify exactly, because it depends on the "surface to volume ratio" of a given method or message handler, that is, the ratio between the amount of data that needs to be converted back and forth and the amount of actual work the method/handler needs to perform.</p>

<p>In order to maximize performance it's important to carefully design the public interface of relational automata in order to minimize the amount of data that has to be transferred between the hand-written and the generated parts of the codebase. Guidelines and examples of how to do so will be published soon, but in practice that's easier than it sounds. That's because, even though it can be used to replace an embedded database, Cell is not a database but a fully-featured programming language, and computation that needs to access the data held by the Cell side of the code can, in the vast majority of cases, be done directly in Cell, without involving the host language. Most of the time, you'll need to transfer only data that is used for I/O operations, which cannot be done directly in Cell: for example, when such data has to be displayed to the user or sent to another computer or application. In those cases, the computational costs or the intrinsic latency of the I/O will typically dwarf the costs of the data conversions.</p>

<p>Time to look at some numbers. These are the loading times for Cell embedded into Java (the numbers are for version 0.4 of the compiler, which is a bit slower than the most recent one):</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Standalone</th>
    <th class='number-header'>Embedded</th>
    <th class='number-header'>Ratio</th>
  </tr>
  <tr>
    <td>movies.csv</td>
    <td class='number'>402</td>
    <td class='number'>519</td>
    <td class='number'>1.29</td>
  </tr>
  <tr>
    <td>actors.csv</td>
    <td class='number'>1936</td>
    <td class='number'>1844</td>
    <td class='number'>0.95</td>
  </tr>
  <tr>
    <td>directors.csv</td>
    <td class='number'>82</td>
    <td class='number'>75</td>
    <td class='number'>0.91</td>
  </tr>
  <tr>
    <td>movies_directors.csv</td>
    <td class='number'>258</td>
    <td class='number'>238</td>
    <td class='number'>0.92</td>
  </tr>
  <tr>
    <td>movies_genres.csv</td>
    <td class='number'>233</td>
    <td class='number'>190</td>
    <td class='number'>0.81</td>
  </tr>
  <tr>
    <td>roles.csv</td>
    <td class='number'>8136</td>
    <td class='number'>8940</td>
    <td class='number'>1.09</td>
  </tr>
  <tr>
    <td>Total</td>
    <td class='number'>11047</td>
    <td class='number'>11806</td>
    <td class='number'>1.06</td>
  </tr>
</table>
</p>

<p>The first column shows the results when running the Cell-only program, and are exactly the same numbers we saw previously, the second column shows the result of running the tests in embedded mode, and the last one the ratio between the two. Not much of a difference. Updates are shown here:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Standalone</th>
    <th class='number-header'>Embedded</th>
    <th class='number-header'>Ratio</th>
  </tr>
  <tr>
    <td>U1</td>
    <td class='number'>47</td>
    <td class='number'>40</td>
    <td class='number'>0.85</td>
  </tr>
  <tr>
    <td>U2</td>
    <td class='number'>256</td>
    <td class='number'>248</td>
    <td class='number'>0.96</td>
  </tr>
  <tr>
    <td>U3</td>
    <td class='number'>25</td>
    <td class='number'>23</td>
    <td class='number'>0.92</td>
  </tr>
  <tr>
    <td>U4</td>
    <td class='number'>262</td>
    <td class='number'>257</td>
    <td class='number'>0.98</td>
  </tr>
  <tr>
    <td>U5</td>
    <td class='number'>2717</td>
    <td class='number'>3752</td>
    <td class='number'>1.38</td>
  </tr>
  <tr>
    <td>U6</td>
    <td class='number'>201</td>
    <td class='number'>119</td>
    <td class='number'>0.59</td>
  </tr>
  <tr>
    <td>U7</td>
    <td class='number'>7</td>
    <td class='number'>8</td>
    <td class='number'>1.14</td>
  </tr>
</table>

<!--
[47, 256, 25, 262, 2717, 201, 7]
[36, 228, 26, 348, 1224, 70, 11]
[45, 361, 29, 351, 1899, 66, 7]

[1.3, 1.12, 0.96, 0.75, 2.21, 2.87, 0.63]
[1.04, 0.7, 0.86, 0.74, 1.43, 3.04, 1.0]
3515 1943 2758
1.8 1.27
 --></p>

<p>It looks like U5 has become somewhat slower, but that's probably an illusion. It's more likely that the performance hit is taken during the loading phase, and it only appears to happen here because the garbage collector decides to kick in at this particular time. Finally, these are the results for our set of queries:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Standalone</th>
    <th class='number-header'>Embedded</th>
    <th class='number-header'>Ratio</th>
  </tr>
  <tr>
    <td>Q1</td>
    <td class='number'>223</td>
    <td class='number'>226</td>
    <td class='number'>1.01</td>
  </tr>
  <tr>
    <td>Q2</td>
    <td class='number'>5705</td>
    <td class='number'>5680</td>
    <td class='number'>0.99</td>
  </tr>
  </tr>
    <td>Q3</td>
    <td class='number'>5149</td>
    <td class='number'>5972</td>
    <td class='number'>1.15</td>
  </tr>
  <tr>
    <td>Q4</td>
    <td class='number'>201</td>
    <td class='number'>198</td>
    <td class='number'>0.98</td>
  </tr>
  <tr>
    <td>Q5</td>
    <td class='number'>176</td>
    <td class='number'>180</td>
    <td class='number'>1.02</td>
  </tr>
  <tr>
    <td>Q6</td>
    <td class='number'>537</td>
    <td class='number'>526</td>
    <td class='number'>0.97</td>
  </tr>
  <tr>
    <td>Q7</td>
    <td class='number'>3859</td>
    <td class='number'>3927</td>
    <td class='number'>1.01</td>
  </tr>
  <tr>
    <td>Q8</td>
    <td class='number'>4941</td>
    <td class='number'>8665</td>
    <td class='number'>1.75</td>
  </tr>
  <tr>
    <td>Q9</td>
    <td class='number'>3538</td>
    <td class='number'>4159</td>
    <td class='number'>1.17</td>
  </tr>
  <tr>
    <td>Q10</td>
    <td class='number'>4210</td>
    <td class='number'>15406</td>
    <td class='number'>3.65</td>
  </tr>
  <tr>
    <td>Q11</td>
    <td class='number'>360</td>
    <td class='number'>796</td>
    <td class='number'>2.21</td>
  </tr>
  <tr>
    <td>Q12</td>
    <td class='number'>511</td>
    <td class='number'>1492</td>
    <td class='number'>2.91</td>
  </tr>
</table>
</p>

<p>Apart from Q11 the queries that exhibit the worst slowdowns are Q8, Q10, Q12, which is not surprising, since they all do very little work but return a lot of data that needs to be converted. Q11 on the other hand is an example of a computation that is unnecessarily split between the Cell and Java sides of the code. The overhead almost entirely disappears if it is performed entirely in Cell.</p>


<h3>Saving and loading the dataset</h3>

<p>The last thing we need to check is how long it takes to load and save the dataset using the generated <code class='inline-code-box'><span class='inline-code'>void load(Reader)</span></code> and <code class='inline-code-box'><span class='inline-code'>void save(Writer)</span></code> methods. Those methods use the standard literal representation of Cell data, which is rather verbose: the ~140 MB of CSV files used as input increase in size to ~400 MB when saved in the standard Cell format. The tests have also been performed on smaller version of the dataset, which results in a file size of ~170 MB.</p>

<p>When compiling to Java (results for the C# code generator will be added soon) saving the entire dataset takes between <code class='inline-code-box'><span class='inline-code'>10s</span></code> and <code class='inline-code-box'><span class='inline-code'>11s</span></code> on first run, which goes down to around <code class='inline-code-box'><span class='inline-code'>6.5s</span></code> once the JVM warms up on the machine used these tests. In order to get those results though, it's necessary to manually increase (with the <code class='inline-code-box'><span class='inline-code'>-Xms</span></code> and <code class='inline-code-box'><span class='inline-code'>-Xms</span></code> command line flags) the amount of memory used by the JVM, otherwise the number stays at <code class='inline-code-box'><span class='inline-code'>~10s</span></code> even after the JVM has warmed up. Saving the smaller version of the dataset takes between <code class='inline-code-box'><span class='inline-code'>6s</span></code> and <code class='inline-code-box'><span class='inline-code'>7s</span></code> on first run, which goes down to less than <code class='inline-code-box'><span class='inline-code'>3s</span></code> after a couple iterations. There's no need to tweak the memory settings of the JVM in this case.</p>

<p>Loading the dataset takes around <code class='inline-code-box'><span class='inline-code'>25s</span></code> on first run, and about <code class='inline-code-box'><span class='inline-code'>15s</span></code> once the JVM has warmed up. The latter time is not too bad (it is, after all, more or less the same time it takes the handwritten C# code to load the data from the original CSV files), but since loading the data is typically one of the first things an application would do, in most cases you would be stuck with the cold-run performance. Loading the smaller dataset takes about <code class='inline-code-box'><span class='inline-code'>15s</span></code> seconds on the first run, and a little over <code class='inline-code-box'><span class='inline-code'>6s</span></code> seconds afterwards.</p>

<p>Here there's still room for improvement, for example by replacing <code class='inline-code-box'><span class='inline-code'>java.io.Reader</span></code> and <code class='inline-code-box'><span class='inline-code'>java.io.Writer</span></code> with the NIO API, and by switching to asynchronous I/O. The longer term solution though is to define a more compact binary format that is equivalent to the textual representation (with a tool to convert between the two) but faster to read and write.</p>


        </article>
      </div>

      <aside id="sidebar">
        <div id='pages'>
          <ul class='toc'>
            <li>Start Here
              <ul class="toc">
                <li><a href='index.html'>Home</a></li>
                <li><a href='overview.html'>Overview</a></li>
                <li><a href='faq.html'>FAQ</a></li>
                <!-- <li><a href='quick.html'>Quick overview</a></li> -->
                <li><a href='example.html'>Introductory example</a></li>
                <li><a href='comparison.html'>A comparison with OOP</a></li>
              </ul>
            </li>
            <li>Rationale
              <ul class="toc">
                <li><a href='relations.html'>Why relations are better than objects</a>
                <!-- <li><a href='state.html'>State</a></li> -->
                <!-- <li><a href='functional.html'>Functional programming</a></li> -->
                <!-- <li><a href='integrity.html'>Encapsulation, equality and data integrity</a></li> -->
              </ul>
            </li>
            <li>Values and Types
              <ul class="toc">
                <li><a href='data.html'>Data</a></li>
                <li><a href='types.html'>Types</a></li>
              </ul>
            </li>
            <li>The Functional Language
              <ul class="toc">
                <li><a href='functions.html'>Functions</a></li>
                <li><a href='imperative.html'>Imperative code</a></li>
                <li><a href='procedures.html'>Procedures</a></li>
                <li><a href='typechecking.html'>Type checking</a></li>
                <li><a href='miscellanea.html'>Protocols, implicit arguments and memoization</a></li>
                <li><a href='benchmarks-functional.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Relational Automata
              <ul class="toc">
                <li><a href='relational.html'>Schemas</a></li>
                <li><a href='data-modeling.html'>Data modeling</a></li>
                <li><a href='methods.html'>Methods</a></li>
                <li><a href='aggregate-functions.html'>Aggregate functions</a></li>
                <li><a href='inheritance.html'>Inheritance and polymorphism</a></li>
                <li><a href='wiring.html'>Wiring automata together</a></li>
                <li><a href='design.html'>Design Process</a></li>
                <li><a href='updates.html'>State updates</a></li>
                <li><a href='using-relational.html'>Using relational automata</a></li>
                <li><a href='benchmarks-relational.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Reactive Automata
              <ul class="toc">
                <li><a href='reactive.html'>Reactive automata</a></li>
                <li><a href='using-reactive.html'>Using reactive automata</a></li>
                <li><a href='reactive-future-work.html'>Future work</a></li>
              </ul>
            </li>
            <li>Interfacing with...
              <ul class="toc">
                <li><a href='interface-java.html'>Java</a></li>
                <li><a href='interface-cs.html'>C#</a></li>
              </ul>
            </li>
            <li>Network architecture
              <ul class="toc">
                <li><a href='network-architecture.html'>Overview</a></li>
              </ul>
            <li>Miscellanea
              <ul class="toc">
                <li><a href='getting-started.html'>Getting started</a></li>
                <li><a href='standard-library.html'>Standard library</a></li>
                <li><a href='status-roadmap.html'>Status and roadmap</a></li>
                <!-- <li><a href='community.html'>Community and contacts</a></li> -->
              </ul>
            </li>

          </ul>
        </div>
      </aside>
    </div>
  </div>
</body>
</html>
