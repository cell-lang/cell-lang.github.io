<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta content="width=device-width,initial-scale=1" name="viewport">
  <meta name="description" content="The Cell Programming Language">

  <title>The Cell Programming Language</title>

  <link href="./fonts.css" rel="stylesheet" type="text/css" media="screen">
  <link href="./main.css" rel="stylesheet">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113669835-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113669835-1');
  </script>

</head>

<body>
  <div id="container">

    <header id="topbar">
    </header>

    <div id="main-container">
      <div id="main">
        <article class="content">
<h2>Benchmarks</h2>

<p>The benchmarks we'll be examining in this chapter are meant to test the performance of code that updates and queries the state of relational automata, and compare it to equivalent hand-written Java or C# code (Benchmarks that test the functional subset of the language for purely computational tasks are available <a href='benchmarks-functional.html'>here</a>).</p>

<p>Compared to garbage-collected, object-oriented languages like Java or C#, Cell has a number of both structural advantages and disadvantages in terms of performance. One major disadvantage is the deferred update model of relational automata: when an instruction that updates a member or mutable relation variable is executed, the update is not applied immediately, but stored in temporary memory until the message handler returns, which obviously involves a certain amount of overhead. A separate but related source of overhead is support for transactions. Another disadvantage is that in Cell, you can (and usually will) specify a set of integrity constraints (that is, keys and foreign keys) on the state of relational automata that need to be checked at runtime.  A static analysis of the codebase can remove some of this overhead, but not all of it all the time. A more general problem is that mutability in Cell is subject to a number of restrictions that are bound to negatively affect performance in at least some situations.</p>

<p>On the other hand, relational automata naturally lend themselves to being implemented using techniques borrowed from the Entity/Component architecture and more generally from data-oriented design. One advantage of these architectures is that they vastly reduce the number of cache misses by improving the locality of the data. As we'll see later, they also seem to put less strain on the garbage collector, which is not suprising: having, say, a million instances of a class with five member variables in OOP means having a million distinct blocks of memory to keep track of, but with the E/C architecture you would end up with five arrays of one million elements each plus a hashtable (another array), which are much easier for the garbage collector to deal with.</p>

<p>While the code generated by the Cell compiler is already very fast, remember that optimization is still a work in progress: there's a lot left to do and, presumably, at least some margin for improvement.</p>


<h3>The IMDB movie database</h3>

<p>This example will make use of a a subset of the data in the IMDB movie database. The dataset is contained in a number of CSV files of moderate size (~140 MB in total). The various versions of the code will parse and load the dataset into memory, run a number of queries on it and finally update it in various ways. Both the code and the dataset are available on <a href='https://github.com/cell-lang/example-imdb/'>github</a> (the relevant files are <a href='https://github.com/cell-lang/example-imdb/blob/master/cell/main.cell'>main.cell</a> and <a href='https://github.com/cell-lang/example-imdb/blob/master/cell/imdb.cell'>imdb.cell</a> for Cell, <a href='https://github.com/cell-lang/example-imdb/blob/master/java/imdb.java'>imdb.java</a> for Java and <a href='https://github.com/cell-lang/example-imdb/blob/master/csharp/imdb.cs'>imdb.cs</a> for C#). If you have any questions or comments or if there's anything you would like to see added to this set of benchmarks, just leave a message in the <a href='https://groups.google.com/d/forum/cell-lang'>forum</a>.</p>

<p>All tests were run on a dual-core Intel Celeron 1005M running Lubuntu Linux 18.10, using either the Java HotSpot Server VM (version 16.0.2) or the .NET Core SDK (version 3.1.426). The code was run on a single core, using the <code class='inline-code-box'><span class='inline-code'>taskset</span></code> command. Data on multi-core performance will be added in the near future.</p>

<p>Each test was run 25 times, but the first 5 iteractions were discarded, so as to give the JVM/CLR time to warm up, and the remaining 20 were averaged. Cell took longer than Java to warm up (it's just more code) and C# took barely any time at all.</p>

<p>Here's the visual representation of the structure of input dataset:</p>

<p><div><img src='imdb.svg' style='width:100%'></div></p>

<p>and this is the definition of the relational automaton we'll be using to store it:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>schema</span> <span class='m'>MoviesDB</span> {
  actor(<span class='m'>Actor</span>)
    first_name  : <span class='m'>String</span>,
    last_name   : <span class='m'>String</span>,
    gender      : <span class='m'>Gender</span>;

  movie(<span class='m'>Movie</span>)
    name    : <span class='m'>String</span>,
    year    : <span class='m'>Int</span>,
    rank    : <span class='m'>Float</span>,
    genre*  : <span class='m'>Genre</span>;

  director(<span class='m'>Director</span>)
    director_first_name : <span class='m'>String</span>,
    director_last_name  : <span class='m'>String</span>;

  acted_in(<span class='m'>Actor</span>, <span class='m'>Movie</span>)
    role* : <span class='m'>String</span>;

  directed(<span class='m'>Director</span>, <span class='m'>Movie</span>);

  acted_in(a, m) -&gt; actor(a), movie(m);
  directed(d, m) -&gt; director(d), movie(m);

  <span class='c'>// More stuff here</span>
  ...
}
</section>
</figure>
</code></pre>


<h3>Loading the dataset</h3>

<p>The first test consists of parsing each of the CSV files and inserting the data into the corresponding relation variables in the case of Cell, or creating and wiring the corresponding set of objects for Java and C#. The results are show in the following table (all times are in milliseconds):</p>

<p><table class='types-table'>
  <tr>
    <th/>
    <th class='number-header'>Cell (via C++)</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>C#</th>
  </tr>
  <tr>
    <td>movies.csv</td>
    <td class='number'>166</td>
    <td class='number'>412</td>
    <td class='number'>1099</td>
  </tr>
  <tr>
    <td>actors.csv</td>
    <td class='number'>579</td>
    <td class='number'>2244</td>
    <td class='number'>4643</td>
  </tr>
  <tr>
    <td>directors.csv</td>
    <td class='number'>33</td>
    <td class='number'>151</td>
    <td class='number'>350</td>
  </tr>
  <tr>
    <td>movies_directors.csv</td>
    <td class='number'>113</td>
    <td class='number'>232</td>
    <td class='number'>212</td>
  </tr>
  <tr>
    <td>movies_genres.csv</td>
    <td class='number'>108</td>
    <td class='number'>344</td>
    <td class='number'>456</td>
  </tr>
  <tr>
    <td>roles.csv</td>
    <td class='number'>3033</td>
    <td class='number'>4041</td>
    <td class='number'>13031</td>
  </tr>
  <tr>
    <td>Total</td>
    <td class='number'>4032</td>
    <td class='number'>7424</td>
    <td class='number'>19791</td>
  </tr></table></p>

<p>The first column show the loading times for the code produced by the Cell-to-C++ code generator, and the second and third ones the equivalent time for the handwritten, object-oriented Java and C# code respectively. Each row correspond to a different CSV file, save for the last one which shows the totals. The next table shows the same results normalized:</p>

<p><table class='types-table'>
  <tr>
    <th/>
    <th class='number-header'>Cell (via C++)</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>C#</th>
  </tr>

  <tr>
    <td>movies.csv</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.48</td>
    <td class='number'>6.62</td>
  </tr>
  <tr>
    <td>actors.csv</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>3.88</td>
    <td class='number'>8.02</td>
  </tr>
  <tr>
    <td>directors.csv</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>4.58</td>
    <td class='number'>10.61</td>
  </tr>
  <tr>
    <td>movies_directors.csv</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.05</td>
    <td class='number'>1.88</td>
  </tr>
  <tr>
    <td>movies_genres.csv</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>3.19</td>
    <td class='number'>4.22</td>
  </tr>
  <tr>
    <td>roles.csv</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.33</td>
    <td class='number'>4.30</td>
  </tr>
  <tr>
    <td>Mean (Geometric)</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.70</td>
    <td class='number'>5.17</td>
  </tr>

</table></p>

<p>For each row the times are scaled so that the best one becames 1.0. As you can see Cell is always faster, followed by Java, with C# a distant third.</p>

<p>Note that the individual numbers in the above tables are not particularly reliable (only the totals are), because a lot depends on when the garbage collector decides to kick in, which varies depending on how the tests are set up. A better analysis is definitely needed to factor this out, and it will be provided in the near future.</p>

<p>Since this phase of the test is dominated by object creation, which puts a lot of pressure on the garbage collector, it's actually interesting to see what the numbers would be in an "infinite memory" scenario, which can be approximated by setting (with the <code class='inline-code-box'><span class='inline-code'>-Xms</span></code> and <code class='inline-code-box'><span class='inline-code'>-Xmx</span></code> options) the amount of memory available to the JVM to a sufficiently large amount, and by explicitly invoking the garbage collector before loading each individual file (obviously, the times spent doing the preventive garbage collection is not included in the figures shown here):</p>

<p><table class='types-table'>
  <tr>
    <th/>
    <th class='number-header'>Cell (via C++)</th>
    <th class='number-header'>Java</th>
  </tr>
  <tr>
    <td>movies.csv</td>
    <td class='number'>166</td>
    <td class='number'>127</td>
  </tr>
  <tr>
    <td>actors.csv</td>
    <td class='number'>579</td>
    <td class='number'>989</td>
  </tr>
  <tr>
    <td>directors.csv</td>
    <td class='number'>33</td>
    <td class='number'>25</td>
  </tr>
  <tr>
    <td>movies_directors.csv</td>
    <td class='number'>113</td>
    <td class='number'>139</td>
  </tr>
  <tr>
    <td>movies_genres.csv</td>
    <td class='number'>108</td>
    <td class='number'>78</td>
  </tr>
  <tr>
    <td>roles.csv</td>
    <td class='number'>3033</td>
    <td class='number'>2151</td>
  </tr>
  <tr>
    <td>Total</td>
    <td class='number'>4032</td>
    <td class='number'>3509</td>
  </tr>
</table>
</p>

<p>Here are the normalized figures:</p>

<p><table class='types-table'>
  <tr>
    <th/>
    <th class='number-header'>Cell (via C++)</th>
    <th class='number-header'>Java</th>
  </tr>
  <tr>
    <td>movies.csv</td>
    <td class='number'>1.31</td>
    <td class='highlighted-number'>1.00</td>
  </tr>
  <tr>
    <td>actors.csv</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.71</td>
  </tr>
  <tr>
    <td>directors.csv</td>
    <td class='number'>1.32</td>
    <td class='highlighted-number'>1.00</td>
  </tr>
  <tr>
    <td>movies_directors.csv</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.23</td>
  </tr>
  <tr>
    <td>movies_genres.csv</td>
    <td class='number'>1.38</td>
    <td class='highlighted-number'>1.00</td>
  </tr>
  <tr>
    <td>roles.csv</td>
    <td class='number'>1.41</td>
    <td class='highlighted-number'>1.00</td>
  </tr>
  <tr>
    <td>Mean (Geometric)</td>
    <td class='number'>1.22</td>
    <td class='number'>1.13</td>
  </tr>
</table></p>

<p>As you can see, with the garbage collector out of the way, Java is still a bit faster than Cell, which is not particularly surprising: object creation is extremely fast in Java, while the data structures used by Cell are more complex, and updates are also slowed down by factors (transactions, integrity checks, etc.) that have no equivalent in OOP. But much of that advantage is then lost by overloading the garbage collector.</p>


<h3>Updating the dataset</h3>

<p>We'll now be performing a number of update operation, that are described here:</p>

<ul><li>U1: Increments the rank of all movies released before a given year by a specified amount.</li><li>U2: For each actor, computes the average rank of the movies they appear in, and stores the result in the <code class='inline-code-box'><span class='inline-code'>actor_rank</span></code> relation variable or in the <code class='inline-code-box'><span class='inline-code'>avgMoviesRank</span></code> member variable.</li><li>U3: For each director, computes the average rank of the movies they directed, and stores the result in the <code class='inline-code-box'><span class='inline-code'>director_rank</span></code> relation variable or in the <code class='inline-code-box'><span class='inline-code'>avgMoviesRank</span></code> member variable.</li><li>U4: Randomly generates a list of movie ids, and for each of them increments their rank and updates the rank of all actors and directors that worked on it.</li><li>U5: Deletes all movies below a given rank.</li><li>U6: Deletes all actors that do not appear in at least one of the remaining movies.</li><li>U7: Deletes all directors that did not work on any of the remaining movies.</li></ul>

<p>The results are shown here:</p>

<p><table class='types-table'>
  <tr>
    <th/>
    <th class='number-header'>Cell (via C++)</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>C#</th>
  </tr>
  <tr>
    <td>U1</td>
    <td class='number'>166</td>
    <td class='number'>419</td>
    <td class='number'>1198</td>
  </tr>
  <tr>
    <td>U2</td>
    <td class='number'>579</td>
    <td class='number'>2360</td>
    <td class='number'>4181</td>
  </tr>
  <tr>
    <td>U3</td>
    <td class='number'>33</td>
    <td class='number'>197</td>
    <td class='number'>43</td>
  </tr>
  <tr>
    <td>U4</td>
    <td class='number'>113</td>
    <td class='number'>174</td>
    <td class='number'>219</td>
  </tr>
  <tr>
    <td>U5</td>
    <td class='number'>107</td>
    <td class='number'>302</td>
    <td class='number'>861</td>
  </tr>
  <tr>
    <td>U6</td>
    <td class='number'>3054</td>
    <td class='number'>4291</td>
    <td class='number'>12825</td>
  </tr>
  <tr>
    <td>U7</td>
    <td class='number'>15</td>
    <td class='number'>38</td>
    <td class='number'>41</td>
  </tr>
</table></p>

<p>and here are the normalized ones:</p>

<p><table class='types-table'>
  <tr>
    <th/>
    <th class='number-header'>Cell (via C++)</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>C#</th>
  </tr>
  <tr>
    <td>U1</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.52</td>
    <td class='number'>7.22</td>
  </tr>
  <tr>
    <td>U2</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>4.08</td>
    <td class='number'>7.22</td>
  </tr>
  <tr>
    <td>U3</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>5.97</td>
    <td class='number'>1.30</td>
  </tr>
  <tr>
    <td>U4</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.54</td>
    <td class='number'>1.94</td>
  </tr>
  <tr>
    <td>U5</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.82</td>
    <td class='number'>8.05</td>
  </tr>
  <tr>
    <td>U6</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.41</td>
    <td class='number'>4.20</td>
  </tr>
  <tr>
    <td>U7</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.53</td>
    <td class='number'>2.73</td>
  </tr>
  <tr>
    <td>Mean (Geometric)</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.37</td>
    <td class='number'>3.06</td>
  </tr>
</table></p>

<p>As you can see, Cell is again clearly the fastest one, and C# the slowest.</p>


<h3>Queries</h3>

<p>Let's now compare the performance of computation that does not update the dataset. We'll be running the following set of queries:</p>

<ul><li>Q1: Counting the number of movies whose rank is no less that a given threshold. Repeated for several different values of the threshold.</li><li>Q2: Counting the number of actors who played in at least one movie whose rank was no less than a given threshold. Repeated for several different values of the threshold.</li><li>Q3: For each actor, finding all co-actors in movies with a given minimum rank.</li><li>Q4: Calculating a histogram of movie ages.</li><li>Q5: Calculating the average age of all movies with a given minimum rank.</li><li>Q6: Calculating the sum of the ages of all movies in the dataset.</li><li>Q7: For each movie in a randomly generated set, finding all movies that have actors in common with it.</li><li>Q8: For each actor in a randomly generated set, retrieving the last names of all actors with the same first name. Duplicates are eliminated.</li><li>Q9: Same as Q3, but also returning the number of movies they appeared in together.</li><li>Q10: Same as Q8, but duplicates are not eliminated.</li><li>Q11: For each director, checking if they ever also worked as actors.</li><li>Q12: For each actor, computing the full name by concatenating first and last names.</li></ul>

<p>Some of the queries are a bit bizarre, but they actually manage to test all the basic operations on relations: attribute lookups, navigation, searches and linear scans. The results are shown here in milliseconds:</p>

<p><table class='types-table'>
  <tr>
    <th/>
    <th class='number-header'>Cell (via C++)</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>C#</th>
  </tr>
  <tr>
    <td>Q1</td>
    <td class='number'>78</td>
    <td class='number'>416</td>
    <td class='number'>1040</td>
  </tr>
  <tr>
    <td>Q2</td>
    <td class='number'>2346</td>
    <td class='number'>9365</td>
    <td class='number'>9080</td>
  </tr>
  <tr>
    <td>Q3</td>
    <td class='number'>3365</td>
    <td class='number'>6339</td>
    <td class='number'>9788</td>
  </tr>
  <tr>
    <td>Q4</td>
    <td class='number'>65</td>
    <td class='number'>221</td>
    <td class='number'>484</td>
  </tr>
  <tr>
    <td>Q5</td>
    <td class='number'>24</td>
    <td class='number'>217</td>
    <td class='number'>482</td>
  </tr>
  <tr>
    <td>Q6</td>
    <td class='number'>100</td>
    <td class='number'>861</td>
    <td class='number'>1858</td>
  </tr>
  <tr>
    <td>Q7</td>
    <td class='number'>2725</td>
    <td class='number'>4070</td>
    <td class='number'>4420</td>
  </tr>
  <tr>
    <td>Q8</td>
    <td class='number'>3881</td>
    <td class='number'>3774</td>
    <td class='number'>4577</td>
  </tr>
  <tr>
    <td>Q9</td>
    <td class='number'>5223</td>
    <td class='number'>1724</td>
    <td class='number'>3247</td>
  </tr>
  <tr>
    <td>Q10</td>
    <td class='number'>2781</td>
    <td class='number'>2156</td>
    <td class='number'>2689</td>
  </tr>
  <tr>
    <td>Q11</td>
    <td class='number'>88</td>
    <td class='number'>304</td>
    <td class='number'>160</td>
  </tr>
  <tr>
    <td>Q12</td>
    <td class='number'>148</td>
    <td class='number'>224</td>
    <td class='number'>86</td>
  </tr>
</table></p>

<p>and here is the normalized version:</p>

<p><table class='types-table'>
  <tr>
    <th/>
    <th class='number-header'>Cell (via C++)</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>C#</th>
  </tr>
  <tr>
    <td>Q1</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>5.33</td>
    <td class='number'>13.33</td>
  </tr>
  <tr>
    <td>Q2</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>3.99</td>
    <td class='number'>3.87</td>
  </tr>
  <tr>
    <td>Q3</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.88</td>
    <td class='number'>2.91</td>
  </tr>
  <tr>
    <td>Q4</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>3.40</td>
    <td class='number'>7.45</td>
  </tr>
  <tr>
    <td>Q5</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>9.04</td>
    <td class='number'>20.08</td>
  </tr>
  <tr>
    <td>Q6</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>8.61</td>
    <td class='number'>18.58</td>
  </tr>
  <tr>
    <td>Q7</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.49</td>
    <td class='number'>1.62</td>
  </tr>
  <tr>
    <td>Q8</td>
    <td class='number'>1.03</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.21</td>
  </tr>
  <tr>
    <td>Q9</td>
    <td class='number'>3.03</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.88</td>
  </tr>
  <tr>
    <td>Q10</td>
    <td class='number'>1.29</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.25</td>
  </tr>
  <tr>
    <td>Q11</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>3.45</td>
    <td class='number'>1.82</td>
  </tr>
  <tr>
    <td>Q12</td>
    <td class='number'>1.72</td>
    <td class='number'>2.60</td>
    <td class='highlighted-number'>1.00</td>
  </tr>
  <tr>
    <td>Mean (Geometric)</td>
    <td class='number'>1.17</td>
    <td class='number'>2.69</td>
    <td class='number'>3.51</td>
  </tr>
</table></p>

<p>When compared to Java Cell is much slower for <code class='inline-code-box'><span class='inline-code'>Q9</span></code>, which makes use of a map/dictionary which is repeatedly mutated. In Cell maps only support functional updates, which are reasonably fast, but cannot compete with Java's mutable, hashtable-based maps. It's also somewhat slower for query <code class='inline-code-box'><span class='inline-code'>Q10</span></code>.</p>

<p>Compared to C#, Cell is again slower for <code class='inline-code-box'><span class='inline-code'>Q9</span></code>, and also for <code class='inline-code-box'><span class='inline-code'>Q12</span></code>, but the latter is a special case, as <code class='inline-code-box'><span class='inline-code'>Q12</span></code> is dominated by string concatenation, which is heavily optimized in C# (and Java), but not in Cell.</p>


<h3>Dual core results</h3>

<p>All the figures we've seen so far are for a single-core configuration, and now we'll take a look at what happens with a dual-core one. For Cell nothing changes, as at this stage the Cell compiler doesn't take advantage of the second core, but the figures are different for Java and C#, even though neither program is multithreaded. Here are the results of the loading tests:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>C#</th>
  </tr>

  <tr>
    <td>movies.csv</td>
    <td class='number'>166</td>
    <td class='number'>312</td>
    <td class='number'>235</td>
  </tr>
  <tr>
    <td>actors.csv</td>
    <td class='number'>579</td>
    <td class='number'>2590</td>
    <td class='number'>2709</td>
  </tr>
  <tr>
    <td>directors.csv</td>
    <td class='number'>33</td>
    <td class='number'>25</td>
    <td class='number'>480</td>
  </tr>
  <tr>
    <td>movies_directors.csv</td>
    <td class='number'>113</td>
    <td class='number'>220</td>
    <td class='number'>490</td>
  </tr>
  <tr>
    <td>movies_genres.csv</td>
    <td class='number'>108</td>
    <td class='number'>130</td>
    <td class='number'>463</td>
  </tr>
  <tr>
    <td>roles.csv</td>
    <td class='number'>3033</td>
    <td class='number'>5972</td>
    <td class='number'>6657</td>
  </tr>
  <tr>
    <td>Total</td>
    <td class='number'>4032</td>
    <td class='number'>9249</td>
    <td class='number'>11034</td>
  </tr>
</table>
</p>

<p>An you can see Java is (surprisingly) slower when considering the overall loading times, by about 25%, and C# is much faster, by a whopping 80%, but it's still the slowest of the three. I've no explanation for the worsening of Java performance, but I guess the C# improvements might be due to the fact that it's able to run the garbage collector on the second core, which makes a lot of difference here since this set of tests put a lot of pressure on the garbage collector. The individual figures bounce around a lot for both Java and C#, but that's just an artifact in the data caused by the unpredictability of the garbage collector that kicks is at different times in this dual-core configuration.</p>

<p>These are the results for the update tests, both raw and normalized:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>C#</th>
  </tr>

  <tr>
    <td>U1</td>
    <td class='number'>166</td>
    <td class='number'>309</td>
    <td class='number'>253</td>
  </tr>
  <tr>
    <td>U2</td>
    <td class='number'>579</td>
    <td class='number'>2544</td>
    <td class='number'>3485</td>
  </tr>
  <tr>
    <td>U3</td>
    <td class='number'>33</td>
    <td class='number'>26</td>
    <td class='number'>43</td>
  </tr>
  <tr>
    <td>U4</td>
    <td class='number'>113</td>
    <td class='number'>208</td>
    <td class='number'>217</td>
  </tr>
  <tr>
    <td>U5</td>
    <td class='number'>107</td>
    <td class='number'>134</td>
    <td class='number'>442</td>
  </tr>
  <tr>
    <td>U6</td>
    <td class='number'>3054</td>
    <td class='number'>5995</td>
    <td class='number'>6397</td>
  </tr>
  <tr>
    <td>U7</td>
    <td class='number'>15</td>
    <td class='number'>75</td>
    <td class='number'>41</td>
  </tr>
</table>
</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>C#</th>
  </tr>

  <tr>
    <td>U1</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.86</td>
    <td class='number'>1.52</td>
  </tr>
  <tr>
    <td>U2</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>4.39</td>
    <td class='number'>6.02</td>
  </tr>
  <tr>
    <td>U3</td>
    <td class='number'>1.27</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.65</td>
  </tr>
  <tr>
    <td>U4</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.84</td>
    <td class='number'>1.92</td>
  </tr>
  <tr>
    <td>U5</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.25</td>
    <td class='number'>4.13</td>
  </tr>
  <tr>
    <td>U6</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.96</td>
    <td class='number'>2.09</td>
  </tr>
  <tr>
    <td>U7</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>5.00</td>
    <td class='number'>2.73</td>
  </tr>
  <tr>
    <td>Mean (Geometric)</td>
    <td class='number'>1.03</td>
    <td class='number'>2.40</td>
    <td class='number'>2.30</td>
  </tr>
</table>
</p>

<p>Here again the results are made less clear by the intervention of the garbage collector, but it looks like overall not much has changed for Java, while there's a clear (but much smaller than in the loading tests) improvement for C#.</p>

<p>The results of the query tests are more reliable, due to the fact that the garbage collector is not as much of a factor as it is in the other sets of tests. They show a clear deterioration of performance for Java, and no significant difference for C#:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>C#</th>
  </tr>

  <tr>
    <td>Q1</td>
    <td class='number'>78</td>
    <td class='number'>1158</td>
    <td class='number'>1024</td>
  </tr>
  <tr>
    <td>Q2</td>
    <td class='number'>2346</td>
    <td class='number'>12067</td>
    <td class='number'>8939</td>
  </tr>
  <tr>
    <td>Q3</td>
    <td class='number'>3365</td>
    <td class='number'>8188</td>
    <td class='number'>9403</td>
  </tr>
  <tr>
    <td>Q4</td>
    <td class='number'>65</td>
    <td class='number'>606</td>
    <td class='number'>478</td>
  </tr>
  <tr>
    <td>Q5</td>
    <td class='number'>24</td>
    <td class='number'>607</td>
    <td class='number'>477</td>
  </tr>
  <tr>
    <td>Q6</td>
    <td class='number'>100</td>
    <td class='number'>2319</td>
    <td class='number'>1833</td>
  </tr>
  <tr>
    <td>Q7</td>
    <td class='number'>2725</td>
    <td class='number'>5154</td>
    <td class='number'>4359</td>
  </tr>
  <tr>
    <td>Q8</td>
    <td class='number'>3881</td>
    <td class='number'>5039</td>
    <td class='number'>4690</td>
  </tr>
  <tr>
    <td>Q9</td>
    <td class='number'>5223</td>
    <td class='number'>2275</td>
    <td class='number'>2997</td>
  </tr>
  <tr>
    <td>Q10</td>
    <td class='number'>2781</td>
    <td class='number'>3422</td>
    <td class='number'>2803</td>
  </tr>
  <tr>
    <td>Q11</td>
    <td class='number'>88</td>
    <td class='number'>271</td>
    <td class='number'>161</td>
  </tr>
  <tr>
    <td>Q12</td>
    <td class='number'>148</td>
    <td class='number'>152</td>
    <td class='number'>84</td>
  </tr>
</table>
</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Cell</th>
    <th class='number-header'>Java</th>
    <th class='number-header'>C#</th>
  </tr>

  <tr>
    <td>Q1</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>14.85</td>
    <td class='number'>13.13</td>
  </tr>
  <tr>
    <td>Q2</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>5.14</td>
    <td class='number'>3.81</td>
  </tr>
  <tr>
    <td>Q3</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>2.43</td>
    <td class='number'>2.79</td>
  </tr>
  <tr>
    <td>Q4</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>9.32</td>
    <td class='number'>7.35</td>
  </tr>
  <tr>
    <td>Q5</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>25.29</td>
    <td class='number'>19.88</td>
  </tr>
  <tr>
    <td>Q6</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>23.19</td>
    <td class='number'>18.33</td>
  </tr>
  <tr>
    <td>Q7</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.89</td>
    <td class='number'>1.60</td>
  </tr>
  <tr>
    <td>Q8</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.30</td>
    <td class='number'>1.21</td>
  </tr>
  <tr>
    <td>Q9</td>
    <td class='number'>2.30</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.32</td>
  </tr>
  <tr>
    <td>Q10</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>1.23</td>
    <td class='number'>1.01</td>
  </tr>
  <tr>
    <td>Q11</td>
    <td class='highlighted-number'>1.00</td>
    <td class='number'>3.08</td>
    <td class='number'>1.83</td>
  </tr>
  <tr>
    <td>Q12</td>
    <td class='number'>1.76</td>
    <td class='number'>1.81</td>
    <td class='highlighted-number'>1.00</td>
  </tr>
  <tr>
    <td>Mean (Geometric)</td>
    <td class='number'>1.12</td>
    <td class='number'>4.01</td>
    <td class='number'>3.31</td>
  </tr>
</table>
</p>


<h3>Embedded mode</h3>

<p>Cell is primarily meant to be used as an embedded language, so we'll now take a look at its performance for that specific use case. As one might expect, the generated code can sometimes be slower in embedded mode, because of all the data conversion and validation that takes place at the boundary between handwritten and generated code.</p>

<p>The performance hit varies considerably, and it's impossible to quantify exactly, because it depends on the "surface to volume ratio" of a given method or message handler, that is, the ratio between the amount of data that needs to be converted back and forth and the amount of actual work the method/handler needs to perform.</p>

<p>In order to maximize performance it's important to carefully design the public interface of relational automata in order to minimize the amount of data that has to be transferred between the hand-written and the generated parts of the codebase. Guidelines and examples of how to do so will be published soon, but in practice that's easier than it sounds. That's because, even though it can be used to replace an embedded database, Cell is not a database but a fully-featured programming language, and computation that needs to access the data held by the Cell side of the code can, in the vast majority of cases, be done directly in Cell, without involving the host language. Most of the time, you'll need to transfer only data that is used for I/O operations, which cannot be done directly in Cell: for example, when such data has to be displayed to the user or sent to another computer or application. In those cases, the computational costs or the intrinsic latency of the I/O will typically dwarf the costs of the data conversions.</p>

<p>Time to look at some numbers. These are the loading times for Cell embedded into Java (the numbers are for version 0.4 of the compiler, which is somewhat slower than the most recent one):</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Standalone</th>
    <th class='number-header'>Embedded</th>
    <th class='number-header'>Ratio</th>
  </tr>
  <tr>
    <td>movies.csv</td>
    <td class='number'>402</td>
    <td class='number'>519</td>
    <td class='number'>1.29</td>
  </tr>
  <tr>
    <td>actors.csv</td>
    <td class='number'>1936</td>
    <td class='number'>1844</td>
    <td class='number'>0.95</td>
  </tr>
  <tr>
    <td>directors.csv</td>
    <td class='number'>82</td>
    <td class='number'>75</td>
    <td class='number'>0.91</td>
  </tr>
  <tr>
    <td>movies_directors.csv</td>
    <td class='number'>258</td>
    <td class='number'>238</td>
    <td class='number'>0.92</td>
  </tr>
  <tr>
    <td>movies_genres.csv</td>
    <td class='number'>233</td>
    <td class='number'>190</td>
    <td class='number'>0.81</td>
  </tr>
  <tr>
    <td>roles.csv</td>
    <td class='number'>8136</td>
    <td class='number'>8940</td>
    <td class='number'>1.09</td>
  </tr>
  <tr>
    <td>Total</td>
    <td class='number'>11047</td>
    <td class='number'>11806</td>
    <td class='number'>1.06</td>
  </tr>
</table>
</p>

<p>The first column shows the results when running the Cell-only program, and are exactly the same numbers we saw previously, the second column shows the result of running the tests in embedded mode, and the last one the ratio between the two. Not much of a difference. Updates are shown here:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Standalone</th>
    <th class='number-header'>Embedded</th>
    <th class='number-header'>Ratio</th>
  </tr>
  <tr>
    <td>U1</td>
    <td class='number'>47</td>
    <td class='number'>40</td>
    <td class='number'>0.85</td>
  </tr>
  <tr>
    <td>U2</td>
    <td class='number'>256</td>
    <td class='number'>248</td>
    <td class='number'>0.96</td>
  </tr>
  <tr>
    <td>U3</td>
    <td class='number'>25</td>
    <td class='number'>23</td>
    <td class='number'>0.92</td>
  </tr>
  <tr>
    <td>U4</td>
    <td class='number'>262</td>
    <td class='number'>257</td>
    <td class='number'>0.98</td>
  </tr>
  <tr>
    <td>U5</td>
    <td class='number'>2717</td>
    <td class='number'>3752</td>
    <td class='number'>1.38</td>
  </tr>
  <tr>
    <td>U6</td>
    <td class='number'>201</td>
    <td class='number'>119</td>
    <td class='number'>0.59</td>
  </tr>
  <tr>
    <td>U7</td>
    <td class='number'>7</td>
    <td class='number'>8</td>
    <td class='number'>1.14</td>
  </tr>
</table>

<!--
[47, 256, 25, 262, 2717, 201, 7]
[36, 228, 26, 348, 1224, 70, 11]
[45, 361, 29, 351, 1899, 66, 7]

[1.3, 1.12, 0.96, 0.75, 2.21, 2.87, 0.63]
[1.04, 0.7, 0.86, 0.74, 1.43, 3.04, 1.0]
3515 1943 2758
1.8 1.27
 --></p>

<p>It looks like U5 has become somewhat slower, but that's probably an illusion. It's more likely that the performance hit is taken during the loading phase, and it only appears to happen here because the garbage collector decides to kick in at this particular time. Finally, these are the results for our set of queries:</p>

<p><table class='types-table'>
  <tr>
    <th></th>
    <th class='number-header'>Standalone</th>
    <th class='number-header'>Embedded</th>
    <th class='number-header'>Ratio</th>
  </tr>
  <tr>
    <td>Q1</td>
    <td class='number'>223</td>
    <td class='number'>226</td>
    <td class='number'>1.01</td>
  </tr>
  <tr>
    <td>Q2</td>
    <td class='number'>5705</td>
    <td class='number'>5680</td>
    <td class='number'>0.99</td>
  </tr>
  </tr>
    <td>Q3</td>
    <td class='number'>5149</td>
    <td class='number'>5972</td>
    <td class='number'>1.15</td>
  </tr>
  <tr>
    <td>Q4</td>
    <td class='number'>201</td>
    <td class='number'>198</td>
    <td class='number'>0.98</td>
  </tr>
  <tr>
    <td>Q5</td>
    <td class='number'>176</td>
    <td class='number'>180</td>
    <td class='number'>1.02</td>
  </tr>
  <tr>
    <td>Q6</td>
    <td class='number'>537</td>
    <td class='number'>526</td>
    <td class='number'>0.97</td>
  </tr>
  <tr>
    <td>Q7</td>
    <td class='number'>3859</td>
    <td class='number'>3927</td>
    <td class='number'>1.01</td>
  </tr>
  <tr>
    <td>Q8</td>
    <td class='number'>4941</td>
    <td class='number'>8665</td>
    <td class='number'>1.75</td>
  </tr>
  <tr>
    <td>Q9</td>
    <td class='number'>3538</td>
    <td class='number'>4159</td>
    <td class='number'>1.17</td>
  </tr>
  <tr>
    <td>Q10</td>
    <td class='number'>4210</td>
    <td class='number'>15406</td>
    <td class='number'>3.65</td>
  </tr>
  <tr>
    <td>Q11</td>
    <td class='number'>360</td>
    <td class='number'>796</td>
    <td class='number'>2.21</td>
  </tr>
  <tr>
    <td>Q12</td>
    <td class='number'>511</td>
    <td class='number'>1492</td>
    <td class='number'>2.91</td>
  </tr>
</table>
</p>

<p>Apart from Q11 the queries that exhibit the worst slowdowns are Q8, Q10, Q12, which is not surprising, since they all do very little work but return a lot of data that needs to be converted. Q11 on the other hand is an example of a computation that is unnecessarily split between the Cell and Java sides of the code. The overhead almost entirely disappears if it is performed entirely in Cell.</p>


<h3>Saving and loading the dataset</h3>

<p>The last thing we need to check is how long it takes to load and save the dataset using the generated <code class='inline-code-box'><span class='inline-code'>void load(Reader)</span></code> and <code class='inline-code-box'><span class='inline-code'>void save(Writer)</span></code> methods. Those methods use the standard literal representation of Cell data, which is rather verbose: the ~140 MB of CSV files used as input increase in size to ~400 MB when saved in the standard Cell format. The tests have also been performed on smaller version of the dataset, which results in a file size of ~170 MB.</p>

<p>When compiling to Java (results for the C# code generator will be added soon) saving the entire dataset takes between <code class='inline-code-box'><span class='inline-code'>10s</span></code> and <code class='inline-code-box'><span class='inline-code'>11s</span></code> on first run, which goes down to around <code class='inline-code-box'><span class='inline-code'>6.5s</span></code> once the JVM warms up on the machine used these tests. In order to get those results though, it's necessary to manually increase (with the <code class='inline-code-box'><span class='inline-code'>-Xms</span></code> and <code class='inline-code-box'><span class='inline-code'>-Xms</span></code> command line flags) the amount of memory used by the JVM, otherwise the number stays at <code class='inline-code-box'><span class='inline-code'>~10s</span></code> even after the JVM has warmed up. Saving the smaller version of the dataset takes between <code class='inline-code-box'><span class='inline-code'>6s</span></code> and <code class='inline-code-box'><span class='inline-code'>7s</span></code> on first run, which goes down to less than <code class='inline-code-box'><span class='inline-code'>3s</span></code> after a couple iterations. There's no need to tweak the memory settings of the JVM in this case.</p>

<p>Loading the dataset takes around <code class='inline-code-box'><span class='inline-code'>25s</span></code> on first run, and about <code class='inline-code-box'><span class='inline-code'>15s</span></code> once the JVM has warmed up. The latter time is not too bad (it is, after all, more or less the same time it takes the handwritten C# code to load the data from the original CSV files), but since loading the data is typically one of the first things an application would do, in most cases you would be stuck with the cold-run performance. Loading the smaller dataset takes about <code class='inline-code-box'><span class='inline-code'>15s</span></code> seconds on the first run, and a little over <code class='inline-code-box'><span class='inline-code'>6s</span></code> seconds afterwards.</p>

<p>Here there's still room for improvement, for example by replacing <code class='inline-code-box'><span class='inline-code'>java.io.Reader</span></code> and <code class='inline-code-box'><span class='inline-code'>java.io.Writer</span></code> with the NIO API, and by switching to asynchronous I/O. The longer term solution though is to define a more compact binary format that is equivalent to the textual representation (with a tool to convert between the two) but faster to read and write.</p>


        </article>
      </div>

      <aside id="sidebar">
        <div id='pages'>
          <ul class='toc'>
            <li>Start Here
              <ul class="toc">
                <li><a href='index.html'>Home</a></li>
                <li><a href='overview.html'>Overview</a></li>
                <li><a href='faq.html'>FAQ</a></li>
                <!-- <li><a href='quick.html'>Quick overview</a></li> -->
                <li><a href='example.html'>Introductory example</a></li>
                <li><a href='comparison.html'>A comparison with OOP</a></li>
              </ul>
            </li>
            <li>Rationale
              <ul class="toc">
                <li><a href='relations.html'>Why relations are better than objects</a>
                <!-- <li><a href='state.html'>State</a></li> -->
                <!-- <li><a href='functional.html'>Functional programming</a></li> -->
                <!-- <li><a href='integrity.html'>Encapsulation, equality and data integrity</a></li> -->
              </ul>
            </li>
            <li>Values and Types
              <ul class="toc">
                <li><a href='data.html'>Data</a></li>
                <li><a href='types.html'>Types</a></li>
              </ul>
            </li>
            <li>The Functional Language
              <ul class="toc">
                <li><a href='functions.html'>Functions</a></li>
                <li><a href='imperative.html'>Imperative code</a></li>
                <li><a href='procedures.html'>Procedures</a></li>
                <li><a href='typechecking.html'>Type checking</a></li>
                <li><a href='miscellanea.html'>Protocols, implicit arguments and memoization</a></li>
                <li><a href='benchmarks-functional.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Relational Automata
              <ul class="toc">
                <li><a href='relational.html'>Schemas</a></li>
                <li><a href='data-modeling.html'>Data modeling</a></li>
                <li><a href='methods.html'>Methods</a></li>
                <li><a href='aggregate-functions.html'>Aggregate functions</a></li>
                <li><a href='inheritance.html'>Inheritance and polymorphism</a></li>
                <li><a href='wiring.html'>Wiring automata together</a></li>
                <li><a href='design.html'>Design Process</a></li>
                <li><a href='updates.html'>State updates</a></li>
                <li><a href='using-relational.html'>Using relational automata</a></li>
                <li><a href='benchmarks-relational.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Reactive Automata
              <ul class="toc">
                <li><a href='reactive.html'>Reactive automata</a></li>
                <li><a href='using-reactive.html'>Using reactive automata</a></li>
                <li><a href='reactive-future-work.html'>Future work</a></li>
              </ul>
            </li>
            <li>Embedded use
              <ul class="toc">
                <li><a href='interface-cpp.html'>C++</a></li>
                <li><a href='interface-java.html'>Java</a></li>
                <li><a href='interface-cs.html'>C#</a></li>
              </ul>
            </li>
            <li>Network architecture
              <ul class="toc">
                <li><a href='network-architecture.html'>Overview</a></li>
              </ul>
            <li>Miscellanea
              <ul class="toc">
                <li><a href='getting-started.html'>Getting started</a></li>
                <li><a href='standard-library.html'>Standard library</a></li>
                <li><a href='status-roadmap.html'>Status and roadmap</a></li>
                <!-- <li><a href='community.html'>Community and contacts</a></li> -->
              </ul>
            </li>

          </ul>
        </div>
      </aside>
    </div>
  </div>
</body>
</html>
