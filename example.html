<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta content="width=device-width,initial-scale=1" name="viewport">
  <meta name="description" content="The Cell Programming Language">

  <title>The Cell Programming Language</title>

  <link href="./fonts.css" rel="stylesheet" type="text/css" media="screen">
  <link href="./main.css" rel="stylesheet">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113669835-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113669835-1');
  </script>

</head>

<body>
  <div id="container">

    <header id="topbar">
    </header>

    <div id="main-container">
      <div id="main">
        <article class="content">
<h2>An introductory example</h2>

<p>This chapter will walk you through a toy example of what is one of the most obvious uses of Cell, namely as an alternative to an embedded SQL database. It shows some basic features of relational automata, but it's not meant to be a comprehensive introduction to them.</p>

<p>The specific example we'll be using was chosen because it is simple and familiar to anyone but at the same time sophisticated enough to provide a glimpse of the advantages of the functional/relational programming paradigm over OOP. But it is a server application, and Cell is not at the moment a good fit for server software. That's because server applications typically have to handle large amounts of persistent data, something that Cell is not (yet) able to do. With Cell, your entire dataset has to fit in RAM and has to be saved explicitly. It takes only a couple lines of code to load or save it, independently of its size or complexity, but there's currently no support for incremental saving, that is, the ability to save only the part of your dataset that has changed since the last save. There's a way (discussed below) to make sure that unsaved data is never lost, even in the event of a software crash or hardware failure (unless the latter involves a disk failure, of course), but in general these limitations make Cell a better fit for desktop, mobile or embedded applications, which usually have to deal with smaller datasets.</p>


<h3>Creating an online forum</h3>

<p>In what follows we'll be implementing a small part of the persistent data structures and core logic needed to create an online forum. The forum will consist of any number of chat groups, each of which has a name and an administrator. User will be able to post in the chat groups after they sign up. In order to do so, they'll have to choose a unique username and provide their name and surname and optionally their date of birth. Once they sign up they will be able to join any number of groups, and in each of them they'll have a reddit-style karma, that can go up or down based on the up or down votes from other users. Karma is group-specific: every user may, and generally will, have a different karma in each of the chat groups it has joined. Users will also be able to friend each other, in order to exchange private messages and easily keep track of one another's posts. Friendship is symmetric: if A is a friend of B, then B also has to be a friend of A.</p>

<p>The first thing we'll need to do is to design our application's persistent data structures. In SQL one could create the following set of tables:</p>

<p><figure class="highlight"><section><pre><code><span style="color: #008800">CREATE</span> <span style="color: #008800">TABLE</span> <span style="color: #0066BB">USERS</span>(
  ID            <span style="color: #333399">INT</span>           <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  USERNAME      <span style="color: #333399">VARCHAR</span>(<span style="color: #0000DD">20</span>)   <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  SIGNUP_DATE   <span style="color: #333399">DATE</span>          <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  NAME          <span style="color: #333399">VARCHAR</span>(<span style="color: #0000DD">40</span>)   <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  SURNAME       <span style="color: #333399">VARCHAR</span>(<span style="color: #0000DD">40</span>)   <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  DATE_OF_BIRTH <span style="color: #333399">DATE</span>,
  <span style="color: #008800">PRIMARY</span> <span style="color: #008800">KEY</span> (ID),
  <span style="color: #008800">UNIQUE</span> (USERNAME)
);

<span style="color: #008800">CREATE</span> <span style="color: #008800">TABLE</span> <span style="color: #0066BB">CHAT_GROUPS</span>(
  ID        <span style="color: #333399">INT</span>           <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  NAME      <span style="color: #333399">VARCHAR</span>(<span style="color: #0000DD">40</span>)   <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  ADMIN     <span style="color: #333399">INT</span>           <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  <span style="color: #008800">PRIMARY</span> <span style="color: #008800">KEY</span> (ID),
  <span style="color: #008800">FOREIGN</span> <span style="color: #008800">KEY</span> (ADMIN) <span style="color: #008800">REFERENCES</span> <span style="color: #0066BB">USERS</span>(ID)
);

<span style="color: #008800">CREATE</span> <span style="color: #008800">TABLE</span> <span style="color: #0066BB">MEMBERS</span>(
  USER        <span style="color: #333399">INT</span>     <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  CHAT_GROUP  <span style="color: #333399">INT</span>     <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  JOINED_ON   <span style="color: #333399">DATE</span>    <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  KARMA       <span style="color: #333399">INT</span>     <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  <span style="color: #008800">PRIMARY</span> <span style="color: #008800">KEY</span> (USER, GROUP),
  <span style="color: #008800">FOREIGN</span> <span style="color: #008800">KEY</span> (USER)       <span style="color: #008800">REFERENCES</span> <span style="color: #0066BB">USERS</span>(ID)
  <span style="color: #008800">FOREIGN</span> <span style="color: #008800">KEY</span> (CHAT_GROUP) <span style="color: #008800">REFERENCES</span> <span style="color: #0066BB">CHAT_GROUPS</span>(ID)
);

<span style="color: #008800">CREATE</span> <span style="color: #008800">TABLE</span> <span style="color: #0066BB">FRIENDSHIPS</span>(
  USER_1  <span style="color: #333399">INT</span>      <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  USER_2  <span style="color: #333399">INT</span>      <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  SINCE   <span style="color: #333399">DATETIME</span> <span style="color: #008800">NOT</span> <span style="color: #003366">NULL</span>,
  <span style="color: #008800">PRIMARY</span> <span style="color: #008800">KEY</span> (USER_1, USER_2),
  <span style="color: #008800">FOREIGN</span> <span style="color: #008800">KEY</span> (USER_1) <span style="color: #008800">REFERENCES</span> <span style="color: #0066BB">USERS</span>(ID),
  <span style="color: #008800">FOREIGN</span> <span style="color: #008800">KEY</span> (USER_2) <span style="color: #008800">REFERENCES</span> <span style="color: #0066BB">USERS</span>(ID)
);
</code></pre></section></figure>
</p>

<p>Note that the <code class='inline-code-box'><span class='inline-code'>USERNAME</span></code> field in <code class='inline-code-box'><span class='inline-code'>USERS</span></code> has to be unique and that all fields in all tables are mandatory, with the only exception of <code class='inline-code-box'><span class='inline-code'>DATE_OF_BIRTH</span></code> in <code class='inline-code-box'><span class='inline-code'>USERS</span></code>.</p>

<p>In order to create something equivalent in Cell, we'll need to define a relational automaton. At first glance, a relational automaton looks a bit like a class in object-oriented languages: it combines a (mutable) data structure with the code that manipulates it. The similarities end there, though. One of the major differences is that you can make use of relations when defining the (type of the) state of a relational automaton. (The term “relation” is just another name for what in SQL is called a table. For a more formal definition, check the Wikipedia entries for <a href='https://en.wikipedia.org/wiki/Binary_relation'>binary</a> and <a href='https://en.wikipedia.org/wiki/Finitary_relation'>n-ary</a> relations). This is the definition of an automaton that is more or less equivalent, in terms of information content, to the above SQL schema:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>UserId</span>  = user_id(<span class='m'>Int</span>);
<span class='k'>type</span> <span class='m'>GroupId</span> = group_id(<span class='m'>Int</span>);

<span class='k'>schema</span> <span class='m'>OnlineForum</span> {
  <span class='c'>// Unique id generation for users and groups</span>
  next_id : <span class='m'>Int</span> = <span class='n'>0</span>;

  <span class='c'>// Users and their attributes</span>
  <span class='c'>// <span class='inline-code'>username</span> must be unique, and <span class='inline-code'>date_of_birth</span> is optional</span>
  user(<span class='m'>UserId</span>)
    username       : <span class='m'>String</span> [<span class='k'>unique</span>],
    signup_date    : <span class='m'>Date</span>,
    first_name     : <span class='m'>String</span>,
    last_name      : <span class='m'>String</span>,
    date_of_birth? : <span class='m'>Date</span>;

  <span class='c'>// Chat groups and their attributes</span>
  chat_group(<span class='m'>GroupId</span>)
    name  : <span class='m'>String</span>,
    admin : <span class='m'>UserId</span>;

  <span class='c'>// Foreign key integrity constraint. States that</span>
  <span class='c'>// every group administrator must also be a valid user</span>
  admin(_, id) -&gt; user(id);

  <span class='c'>// Membership relationship between users</span>
  <span class='c'>// and groups, and its attributes</span>
  member(<span class='m'>UserId</span>, <span class='m'>GroupId</span>)
    joined_on : <span class='m'>Date</span>,
    karma     : <span class='m'>Int</span>;

  <span class='c'>// Another foreign key integrity constraint.</span>
  <span class='c'>// States that the <span class='inline-code'>member</span> relation can only</span>
  <span class='c'>// reference valid users and chat groups</span>
  member(u, g) -&gt; user(u), chat_group(g);

  <span class='c'>// Stores friendship information between user,</span>
  <span class='c'>// with its only attribute. The relation is</span>
  <span class='c'>// declared symmetric, the order in which the</span>
  <span class='c'>// user identifiers are stored doesn't matter</span>
  friends(<span class='m'>UserId</span> | <span class='m'>UserId</span>)
    since : <span class='m'>Time</span>;

  <span class='c'>// The <span class='inline-code'>friends</span> relation can only reference valid users</span>
  friends(u1, u2) -&gt; user(u1), user(u2);
}
</section>
</figure>
</code></pre>


<h3>User-defined types and entity identifiers</h3>

<p>The first thing to notice in the Cell code is the presence of the <code class='inline-code-box'><span class='inline-code'>UserId</span></code> and <code class='inline-code-box'><span class='inline-code'>GroupId</span></code> type definitions. In a relational database every entity in the application's domain is usually identified by an integer or sometimes a string while in OOP every entity type is usually mapped to a class that contains all the entity's attributes. In Cell, on the other hand, the recommended approach is to define a custom type like <code class='inline-code-box'><span class='inline-code'>UserId</span></code> whose sole purpose is to identify an entity of a specific type, but to store all its attributes using relations. Doing so provides a modicum of type safety, makes the code more readable, and most importantly allows us to define functions and methods that are polymorphic on the entity type, just like in OOP, while at the same taking advantage of the benefits provided by relations (more on that later). That's made possible by the fact that in Cell, unlike in SQL, the attributes/columns of a relation can be of any user-defined type.</p>

<p>The <code class='inline-code-box'><span class='inline-code'>UserId</span></code> and <code class='inline-code-box'><span class='inline-code'>GroupId</span></code> type definitions may look a bit strange to you if you're not familiar with functional programming: everything is explained in detail in the chapters on <a href='data.html'>data</a> and <a href='types.html'>types</a>, but for now just think of them as records/structs/classes with a single anonymous and public field of type <code class='inline-code-box'><span class='inline-code'>Int</span></code>.</p>


<h3>Entities, attributes and methods</h3>

<p>The first line in the body of <code class='inline-code-box'><span class='inline-code'>OnlineForum</span></code> is the declaration of the member variable <code class='inline-code-box'><span class='inline-code'>next_id</span></code>, which is just a counter that is read and incremented every time we need to create a new user or chat group id. Nothing new there. The lines that follow are more interesting: they declare the data structures that hold basic information about users:</p>

<figure class="highlight">
<section>
<pre><code>user(<span class='m'>UserId</span>)
  username       : <span class='m'>String</span> [<span class='k'>unique</span>],
  signup_date    : <span class='m'>Date</span>,
  first_name     : <span class='m'>String</span>,
  last_name      : <span class='m'>String</span>,
  date_of_birth? : <span class='m'>Date</span>;
</section>
</figure>
</code></pre>

<p>The above declaration makes use of a lot of syntactic sugar. Without it, it would look like this:</p>

<figure class="highlight">
<section>
<pre><code>  user(<span class='m'>UserId</span>);

  username(<span class='m'>UserId</span>, <span class='m'>String</span>) [<span class='k'>key</span>: <span class='n'>0</span>, <span class='k'>key</span>: <span class='n'>1</span>];

  signup_date(<span class='m'>UserId</span>, <span class='m'>Date</span>)  [<span class='k'>key</span>: <span class='n'>0</span>];
  first_name(<span class='m'>UserId</span>, <span class='m'>String</span>) [<span class='k'>key</span>: <span class='n'>0</span>];
  last_name(<span class='m'>UserId</span>, <span class='m'>String</span>)  [<span class='k'>key</span>: <span class='n'>0</span>];

  date_of_birth(<span class='m'>UserId</span>, <span class='m'>Date</span>) [<span class='k'>key</span>: <span class='n'>0</span>];
</section>
</figure>
</code></pre>

<p>Let's examine the "unsweetened" version first. In the SQL version of the schema, we have a single table that stores all the attributes of a user. In Cell, every attribute is stored in a separate relation. The first relation, <code class='inline-code-box'><span class='inline-code'>user</span></code>, is a unary relation, that is, a set. It simply contains the identifiers of all registered users. The other five relations, <code class='inline-code-box'><span class='inline-code'>username</span></code>, <code class='inline-code-box'><span class='inline-code'>signup_date</span></code>, <code class='inline-code-box'><span class='inline-code'>first_name</span></code>, <code class='inline-code-box'><span class='inline-code'>last_name</span></code> and <code class='inline-code-box'><span class='inline-code'>date_of_birth</span></code>, are binary relations, each of which stores a single attribute of the user entity. That is, while in SQL all the information about a user is stored in a single record of the <code class='inline-code-box'><span class='inline-code'>USERS</span></code> table like, for example, <code class='inline-code-box-long'><span class='inline-code'>ID = 0, USERNAME = "ed96", SIGNUP_DATE = 15/02/2018, NAME = "Edward", SURNAME = "Harris", DATE_OF_BIRTH = 30/8/1996</span></code>, the same data in Cell is split among six different tuples/entries, <code class='inline-code-box'><span class='inline-code'>user_id(0)</span></code> in <code class='inline-code-box'><span class='inline-code'>user</span></code>, <code class='inline-code-box'><span class='inline-code'>user_id(0), "ed96"</span></code> in <code class='inline-code-box'><span class='inline-code'>username</span></code>, <code class='inline-code-box'><span class='inline-code'>user_id(0), 15/02/2018</span></code> in <code class='inline-code-box'><span class='inline-code'>signup_date</span></code>, <code class='inline-code-box'><span class='inline-code'>user_id(0), "Edward"</span></code> in <code class='inline-code-box'><span class='inline-code'>name</span></code> and so on. Note that while in SQL each column/argument of a relation is named, in Cell arguments are only identified by their position.</p>

<p>The reasons for splitting into atomic pieces the information that in an SQL database would be contained in a single record/row will be discussed elsewhere, but one very marginal benefit is that it makes accessing the attributes of a given entity syntactically more convenient. As an example, this is how you can define a method that generates the complete name of a user by concatenating their first and last name:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>using</span> <span class='m'>OnlineForum</span> {
  <span class='m'>String</span> full_name(<span class='m'>UserId</span> u) = first_name(u) &amp; <span class='s'>" "</span> &amp; last_name(u);
}
</section>
</figure>
</code></pre>

<p>The syntax <code class='inline-code-box'><span class='inline-code'>name(u)</span></code> looks exactly like a function or method call, and is not that different from the <code class='inline-code-box'><span class='inline-code'>u.name()</span></code> or <code class='inline-code-box'><span class='inline-code'>u.name</span></code> syntax used in conventional languages, and certainly terser than the <code class='inline-code-box-long'><span class='inline-code'>SELECT NAME FROM USERS WHERE ID = AN_ID</span></code> used in SQL.</p>

<p>Methods in Cell are just normal functions which are given access to the state of an automaton. They are declared inside a <code class='inline-code-box'><span class='inline-code'>using</span></code> block, as shown above. Such a block can of course contain any number of methods. Functions and methods in Cell have no side effects, just like in any other pure functional language. They do not modify the state of the program, and they cannot do any I/O: their only purpose is to compute and return a value. The state of an automaton can be mutated, as we'll see later, but any code that does so is kept separate from the rest.</p>


<h3>Keys and searches</h3>

<p>The <code class='inline-code-box'><span class='inline-code'>[key: 0]</span></code> in the declaration of <code class='inline-code-box'><span class='inline-code'>signup_date</span></code>, <code class='inline-code-box'><span class='inline-code'>first_name</span></code>, <code class='inline-code-box'><span class='inline-code'>last_name</span></code> and <code class='inline-code-box'><span class='inline-code'>date_of_birth</span></code> just states that values in the first column of those binary relation have to be unique. In other words, you can only associate a single sign-up date, name, surname or date of birth to each user identifier. An update that violates any of the above integrity constraints is simply aborted, and all the changes it has made to the state of the automaton instance are rolled back, just like in relational databases.</p>

<p>The <code class='inline-code-box'><span class='inline-code'>username</span></code> relation has two keys, one for each column, which means that not only each person can only have a single username, but also each username has to be unique, that is, it can be associated with only one user.</p>

<p>Being able to declaratively enforce the fact that an attribute cannot have the same value for two different entities is one of the many advantages provided by the relational model. Another, more important one, is that you can efficiently search your dataset on any attribute without having to write any extra code. If you wanted, for instance, to write a method that returns the identifiers of all users who signed up on a given date, you could do it like this:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>using</span> <span class='m'>OnlineForum</span> {
  [<span class='m'>UserId</span>] users_who_signed_up_on(<span class='m'>Date</span> d) = [u : u &lt;- signup_date(?, d)];
}
</section>
</figure>
</code></pre>

<p>The <code class='inline-code-box'><span class='inline-code'>signup_date(?, d)</span></code> expression iterates (loosely speaking) through all the entries in <code class='inline-code-box'><span class='inline-code'>signup_date</span></code> whose second argument is equal to <code class='inline-code-box'><span class='inline-code'>d</span></code>. The first result is produced in constant time, <strong>O(1)</strong>, (it's basically a hashtable lookup) and retrieving each subsequent result is, in terms of efficiency, pretty much like iterating through the elements of a list. Searches can be performed, with the same efficiency, on any attribute of the relation, or any combination of them in the case of ternary relations, which we'll examine later.</p>


<h3>Syntactic sugar</h3>

<p>Let's now go back to the syntactically sugared version of the schema/automaton. The following declaration:</p>

<figure class="highlight">
<section>
<pre><code>user(<span class='m'>UserId</span>)
  username       : <span class='m'>String</span> [<span class='k'>unique</span>],
  signup_date    : <span class='m'>Date</span>,
  first_name     : <span class='m'>String</span>,
  last_name      : <span class='m'>String</span>,
  date_of_birth? : <span class='m'>Date</span>;
</section>
</figure>
</code></pre>

<p>is just a more convenient and concise way of declaring all the unsweetened relations above. The question mark that follows the <code class='inline-code-box'><span class='inline-code'>date_of_birth</span></code> field qualifies it as optional. You can also declare "multivalued" attributes using the syntactically sugared notation. In the following code, for example:</p>

<figure class="highlight">
<section>
<pre><code>user(<span class='m'>UserId</span>)
  ... <span class='c'>// Same as before</span>
  phone_number*  : <span class='m'>String</span>;
</section>
</figure>
</code></pre>

<p>the <code class='inline-code-box'><span class='inline-code'>phone_number</span></code> attribute can have any number of values (including zero). That's rewritten by the compiler into a binary relation with no keys, which can have multiple entries for the same <code class='inline-code-box'><span class='inline-code'>UserId</span></code> value:</p>

<figure class="highlight">
<section>
<pre><code>phone_number(<span class='m'>UserId</span>, <span class='m'>String</span>);
</section>
</figure>
</code></pre>

<p>You can also tag an attribute with a <code class='inline-code-box'><span class='inline-code'>+</span></code> sign, which marks it as a mandatory multivalued attribute, that is, one that must have at least one value, and can have more than one.</p>

<figure class="highlight">
<section>
<pre><code>user(<span class='m'>UserId</span>)
  ...
  phone_number+  : <span class='m'>String</span>;
</section>
</figure>
</code></pre>

<p>There's actually more going on with the syntactically sugared notation, but we won't go into detail here.</p>


<h3>Foreign keys</h3>

<p>The next section in the definition of <code class='inline-code-box'><span class='inline-code'>OnlineForum</span></code> is the declaration of the data structures/relations that hold the information about chat groups. It's very similar to what we've seen before. What's new, though, is the line that follows:</p>

<figure class="highlight">
<section>
<pre><code>admin(_, id) -&gt; user(id);
</section>
</figure>
</code></pre>

<p>That's a foreign key declaration, and it states that every chat group administrator must be a valid user, or in other words, that every value in the right column of <code class='inline-code-box'><span class='inline-code'>admin</span></code> must also be an element of <code class='inline-code-box'><span class='inline-code'>user</span></code>. Scrolling down a bit, you'll find the declarations of another two foreign keys, whose meaning should be obvious: in order for user <code class='inline-code-box'><span class='inline-code'>u</span></code> to be a member of chat group <code class='inline-code-box'><span class='inline-code'>g</span></code>, <code class='inline-code-box'><span class='inline-code'>u</span></code> and <code class='inline-code-box'><span class='inline-code'>g</span></code> must be valid user and chat group identifiers respectively, and for users <code class='inline-code-box'><span class='inline-code'>u1</span></code> and <code class='inline-code-box'><span class='inline-code'>u2</span></code> to be online friends, both <code class='inline-code-box'><span class='inline-code'>u1</span></code> and <code class='inline-code-box'><span class='inline-code'>u2</span></code> must be valid user ids:</p>

<figure class="highlight">
<section>
<pre><code>member(u, g) -&gt; user(u), chat_group(g);
friends(u1, u2) -&gt; user(u1), user(u2);
</section>
</figure>
</code></pre>


<h3>Relationships and their attributes</h3>

<p>The next set of relations store the information on which chat groups each user has joined:</p>

<figure class="highlight">
<section>
<pre><code>member(<span class='m'>UserId</span>, <span class='m'>GroupId</span>)
  joined_on : <span class='m'>Date</span>,
  karma     : <span class='m'>Int</span>;
</section>
</figure>
</code></pre>

<p>As you would expect, that's only syntactic sugar for the following relations:</p>

<figure class="highlight">
<section>
<pre><code><span class='c'>// User #0 is a member of chat group #1</span>
member(<span class='m'>UserId</span>, <span class='m'>GroupId</span>);

<span class='c'>// User #0 joined chat group #1 on #2</span>
joined_on(<span class='m'>UserId</span>, <span class='m'>GroupId</span>, <span class='m'>Date</span>) [<span class='k'>key</span>: <span class='n'>0</span>:<span class='n'>1</span>];

<span class='c'>// User #0 has karma #2 in chat group #1</span>
karma(<span class='m'>UserId</span>, <span class='m'>GroupId</span>, <span class='m'>Date</span>) [<span class='k'>key</span>: <span class='n'>0</span>:<span class='n'>1</span>];
</section>
</figure>
</code></pre>

<p>The comment that precedes the declaration of each relation is the informal relation predicate, that is, the informal meaning of each entry in the relation, with <code class='inline-code-box'><span class='inline-code'>#0</span></code>, <code class='inline-code-box'><span class='inline-code'>#1</span></code> and <code class='inline-code-box'><span class='inline-code'>#2</span></code> being the placeholders for the first, second and third argument of the relation respectively.</p>

<p>Each entry in the binary relation <code class='inline-code-box'><span class='inline-code'>member</span></code> encodes what in an E/R model would be called a relationship between two entities, namely the fact that a specific user has joined a specific chat group. It's a many-to-many relationship, with every user being able to join any number of groups, and groups having any number of members. Just like attribute relations like <code class='inline-code-box'><span class='inline-code'>name</span></code> or <code class='inline-code-box'><span class='inline-code'>date_of_birth</span></code> it can be searched efficiently on any attribute: if, for example, <code class='inline-code-box'><span class='inline-code'>u</span></code> the id of a user and <code class='inline-code-box'><span class='inline-code'>g</span></code> that of a chat group (of type <code class='inline-code-box'><span class='inline-code'>UserId</span></code> and <code class='inline-code-box'><span class='inline-code'>GroupId</span></code> respectively), then the expression <code class='inline-code-box'><span class='inline-code'>member(u, ?)</span></code> will (loosely speaking) iterate through the ids of all chat groups <code class='inline-code-box'><span class='inline-code'>u</span></code> has joined, and <code class='inline-code-box'><span class='inline-code'>member(?, g)</span></code> will provide the list of members of group <code class='inline-code-box'><span class='inline-code'>g</span></code>.</p>

<p>The two ternary relations <code class='inline-code-box'><span class='inline-code'>joined_on</span></code> and <code class='inline-code-box'><span class='inline-code'>karma</span></code> store what we can regard as attributes of the membership relationship, as opposed to attributes of entities like users or groups. The first two arguments form a key for both relations, meaning that for each combination of user and group there can be only one join date and one karma, but a user can still, for instance, have a karma in one group and a different one in another. The fact that attributes like these cannot be "attached" to any single entity makes them awkward to model in conventional languages, which use records as their primary composite data structure, but can be represented very elegantly using relations. Accessing the value of one such attribute is very similar to accessing the attributes of an entity, like <code class='inline-code-box'><span class='inline-code'>username</span></code> or <code class='inline-code-box'><span class='inline-code'>admin</span></code>: the expression <code class='inline-code-box'><span class='inline-code'>karma(u, g)</span></code> returns the karma of user <code class='inline-code-box'><span class='inline-code'>u</span></code> in group <code class='inline-code-box'><span class='inline-code'>g</span></code> (and of course will fail if <code class='inline-code-box'><span class='inline-code'>u</span></code> never joined <code class='inline-code-box'><span class='inline-code'>g</span></code>). Similarly, ternary relations can be searched on any argument or combination thereof: <code class='inline-code-box'><span class='inline-code'>joined_on(?, g, d)</span></code>, for instance, will produce a list of all users who joined group <code class='inline-code-box'><span class='inline-code'>g</span></code> on day <code class='inline-code-box'><span class='inline-code'>d</span></code>. Lookups are performed in constant time (<strong>O(1)</strong>), and the same goes for retrieving the first result in any search.</p>


<h3>Symmetric relations</h3>

<p>Finally, we have the <code class='inline-code-box'><span class='inline-code'>friends</span></code> relation and its only attribute, <code class='inline-code-box'><span class='inline-code'>since</span></code>:</p>

<figure class="highlight">
<section>
<pre><code>friends(<span class='m'>UserId</span> | <span class='m'>UserId</span>)
  since : <span class='m'>Time</span>;
</section>
</figure>
</code></pre>

<p>This is how it would look without syntactic sugar:</p>

<figure class="highlight">
<section>
<pre><code><span class='c'>// Users #0 and #1 are online friends</span>
friends(<span class='m'>UserId</span> | <span class='m'>UserId</span>);

<span class='c'>// Users #0 and #1 have been online friends since #2</span>
since(<span class='m'>UserId</span> | <span class='m'>UserId</span>, <span class='m'>Time</span>);
</section>
</figure>
</code></pre>

<p><code class='inline-code-box'><span class='inline-code'>friends</span></code> look similar to <code class='inline-code-box'><span class='inline-code'>member</span></code>, with the only difference being that its two arguments are separated by a vertical bar instead of a comma, which tells the compiler that the <code class='inline-code-box'><span class='inline-code'>friends</span></code> relation is symmetric. Without that, the fact that users <code class='inline-code-box'><span class='inline-code'>u1</span></code> and <code class='inline-code-box'><span class='inline-code'>u2</span></code> are online friends could be recorded as either the <code class='inline-code-box'><span class='inline-code'>u1, u2</span></code> or <code class='inline-code-box'><span class='inline-code'>u2, u1</span></code> entry inside <code class='inline-code-box'><span class='inline-code'>friends</span></code>, or even both of them. That would of course be a problem, because it would force us to account for both possibilities when checking if two users are friends or when deleting such fact from the dataset, thereby making our code more complex and error prone than it needs to be. The problem would be even worse for the <code class='inline-code-box'><span class='inline-code'>since</span></code> relation, as it could end up with two conflicting facts inside it: <code class='inline-code-box'><span class='inline-code'>u1, u2, t1</span></code> and <code class='inline-code-box'><span class='inline-code'>u2, u1, t2</span></code>. By declaring the arguments of <code class='inline-code-box'><span class='inline-code'>friends</span></code> and the first two arguments of <code class='inline-code-box'><span class='inline-code'>since</span></code> symmetric, all these issues will be automatically deal with by the compiler whenever we read the dataset, and insert, update or delete the data in it.</p>


<h3>Messages and message handlers</h3>

<p>Now that we've completed the design of our data structures, it's time to start writing some actual code. We've already written a couple of read-only methods:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>using</span> <span class='m'>OnlineForum</span> {
  <span class='m'>String</span> full_name(<span class='m'>UserId</span> u) = first_name(u) &amp; <span class='s'>" "</span> &amp; last_name(u);

  [<span class='m'>UserId</span>] users_who_signed_up_on(<span class='m'>Date</span> d) = [u : u &lt;- signup_date(?, d)];
}
</section>
</figure>
</code></pre>

<p>but code that mutates the state of an automaton is quite different. The only way to mutate the state of a relational automaton is by sending it a message. A message is just a value, that is, a piece of data. For every type of message an automaton can accept there's a corresponding message handler that is invoked when such a message is received. The message handler is where the actual updating of the state of the automaton instance takes place.</p>

<p>Let's start by defining the message and message handler pairs that add a new user to the dataset:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>AddUser</span> = add_user(
  id:            <span class='m'>UserId</span>,
  username:      <span class='m'>String</span>,
  signup_date:   <span class='m'>Date</span>,
  first_name:    <span class='m'>String</span>,
  last_name:     <span class='m'>String</span>,
  date_of_birth: <span class='m'>Date</span>?
);

<span class='m'>OnlineForum</span>.<span class='m'>AddUser</span> {
  id = <span class='k'>this</span>.id;

  <span class='c'>// Inserting the new user id</span>
  <span class='k'>insert</span> user(id);

  <span class='c'>// Setting all the mandatory attributes</span>
  <span class='k'>insert</span> username(id, <span class='k'>this</span>.username);
  <span class='k'>insert</span> first_name(id, <span class='k'>this</span>.first_name);
  <span class='k'>insert</span> last_name(id, <span class='k'>this</span>.last_name);
  <span class='k'>insert</span> signup_date(id, <span class='k'>this</span>.signup_date);

  <span class='c'>// Setting the (optional) <span class='inline-code'>date_of_birth</span> attribute, if available</span>
  <span class='k'>if</span> <span class='k'>this</span>.date_of_birth?
    <span class='k'>insert</span> date_of_birth(id, <span class='k'>this</span>.date_of_birth);
}
</section>
</figure>
</code></pre>

<p>The first declarations defines the type of the message, which is basically just a record containing all the information about a new user. The <code class='inline-code-box'><span class='inline-code'>date_of_birth</span></code> field is optional. The second declaration defines the message handler, which is pretty straightforward, just a bunch of insert statements, one of which is conditional since <code class='inline-code-box'><span class='inline-code'>date_of_birth</span></code> is optional. The only thing to note is the <code class='inline-code-box'><span class='inline-code'>this</span></code> keyword that is used to access the value of the message. There's also some syntactic sugar for the <code class='inline-code-box'><span class='inline-code'>insert</span></code> statement. The above message handler can be rewritten more tersely as follows:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>OnlineForum</span>.<span class='m'>AddUser</span> {
  <span class='k'>insert</span> user(<span class='k'>this</span>.id)
    username      = <span class='k'>this</span>.username,
    first_name    = <span class='k'>this</span>.first_name,
    last_name     = <span class='k'>this</span>.last_name,
    signup_date   = <span class='k'>this</span>.signup_date,
    date_of_birth = <span class='k'>this</span>.date_of_birth <span class='k'>if</span> <span class='k'>this</span>.date_of_birth?;
}
</section>
</figure>
</code></pre>

<p>Adding new chat groups, memberships and friendships is very similar to adding users, so we can skip over that part. A more interesting message handler is the one that deletes a user from the dataset, since its logic is a bit more sophisticated: if the user is the administrator of one or more chat groups, we'll have to pick a new administrator for them. We'll pseudo-randomly choose one of the members with the highest karma, or just delete the group if there's no one left. Here's the code:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>OnlineForum</span>.delete_user(id: <span class='m'>UserId</span>) {
  id = <span class='k'>this</span>.id;

  <span class='c'>// Deleting a user's data, memberships and friendships</span>
  <span class='c'>// All attributes are deleted automatically when the</span>
  <span class='c'>// corresponding entity or relationship is deleted</span>
  <span class='k'>delete</span> user(id), member(id, *), friends(id, *);

  <span class='c'>// If the user is the administrator of one or more chat groups,</span>
  <span class='c'>// we need to choose a new administrator for them, or delete</span>
  <span class='c'>// them altogether, if there's nobody left</span>
  <span class='k'>for</span> g &lt;- admin(?, id) {
    members = [u : u &lt;- member(?, g), u != id];
    <span class='k'>if</span> members != [] {
      <span class='c'>// The new administrator is randomly chosen</span>
      <span class='c'>// among all members with the highest karma</span>
      new_admin = any(max_by(members, karma($, g)));
      <span class='k'>update</span> admin(g, new_admin);
    }
    <span class='k'>else</span>
      <span class='c'>// No members left, deleting the group</span>
      <span class='k'>delete</span> chat_group(g);
  }
}
</section>
</figure>
</code></pre>

<p>Here we've used a bit of syntactic sugar to avoid an explicit type definition like the <code class='inline-code-box'><span class='inline-code'>type AddUser = ...</span></code> we saw previously. The following definition:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>OnlineForum</span>.delete_user(id: <span class='m'>UserId</span>) {
  ...
}
</section>
</figure>
</code></pre>

<p>is the same as:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>DeleteUser</span> = delete_user(id: <span class='m'>UserId</span>);

<span class='m'>OnlineForum</span>.<span class='m'>DeleteUser</span> {
  ...
}
</section>
</figure>
</code></pre>

<p>save for the fact that type of the message is not explicitly named (how exactly this works will become clear after reading the chapter on <a href='types.html'>types</a>).</p>


<h3>Differences between relational automata and classes</h3>

<p>We mentioned at the beginning of this chapter that relational automata have some superficial similarities with classes in OOP, in that they combine a mutable data structure with the code that manipulates it, but that the similarities end there. It's now time to elaborate a bit on that.</p>

<p>The first difference is that, as we've already seen, the state of an automaton is defined using the relational model. That's a very major difference, which we'll be discussing elsewhere in the documentation.</p>

<p>Second, there's a strict separation between (pure) computation and state updates. Methods can only compute and return values, but do not modify the state of an automaton. Message handlers, on the other hand, can change the state of the automaton, but do not return a value. Keeping computation and updates separate provides many of the benefits of functional programming, while avoiding the difficulties that the latter paradigm has in dealing with state.</p>

<p>Moreover, message handlers are limited in what they can do: they can only modify the state of the automaton instance that receives the message. They cannot do any I/O, and they cannot alter the states of other automata. That means, among other things, that different automaton instances can be safely updated concurrently by different threads, since they do not share mutable state.</p>

<p>Third, all updates are run inside a transaction. If, for whatever reason, an update fails, the message that triggered it is simply discarded and the state of the automaton is left untouched. That provides a very robust error handling mechanism.</p>

<p>Fourth, the behavior of an automaton is deterministic: the state of an automaton instance after a message has been processed depends only on the previous state and the message itself. Combined with the fact that updates can only be triggered by messages, which are just values that can be manipulated and stored like any other piece of data, that means that is very easy to exactly reproduce the entire execution of an automaton, if one takes care to save all messages that are sent to it. If you create another instance of the same automaton type, with the same initial state, and send it the same sequence of messages, you'll reproduce the exact behavior of the original automaton.</p>

<p>That's of course very useful during debugging, because it means that you can reproduce any bug with a minimal effort. It's also handy when refactoring your code, because you can send the same sequence of messages to both the old and the new code, and compare their behavior. You can basically get a lot of regression tests for free.</p>

<p>Automata also support orthogonal persistence. One can, at any time, take a snapshot of the state of an automaton, which can then be saved to persistent storage. Such snapshot can later be used to recreate an identical copy of the original automaton, which will just pick up where the original instance left off. We'll see how to do it in the next paragraphs.</p>

<p>As already mention, the state of an automaton has to be saved explicitly, and there's no way at the moment to save only the part of the state that has changed since the last save. But if you keep a log of the messages received by an automaton, you'll only need to save its state once in a while, without running the risk of losing data: if a crash occurs when your application has some unsaved data, all you need to do is start from the last saved state and resend all messages that were received after that, and you'll recreate the exact state you lost in the crash.</p>

<p>There are also other, more interesting ways to take advantage of the fact that updates are deterministic and message-based, when building distributed applications, but we won't discuss them here.</p>


<h3>Interfacing with Java</h3>

<p>While it is possible to build a complete application with it, Cell is designed to be a domain-specific language, used to generate code for a number of different target languages. The ones that are already supported are C++, Java and C#. We'll make use of the Java code generator here, since it's the one that is in the most advanced stage of development at the moment. When compiling the code that we've seen in this chapter, the code generator will produce an <code class='inline-code-box'><span class='inline-code'>OnlineForum</span></code> class that can be used from your native Java code to instantiate, control and read the state of the instances of the automaton defined in the Cell codebase. Here's the interface of the generated Java class, in pseudo-Java code:</p>

<p><figure class="highlight"><section><pre><code><span class='k'>package</span> net.cell_lang;

<span class='k'>class</span> <span class='m'>OnlineForum</span> {
  <span class='m'>OnlineForum</span>();

  <span class='b'>void</span> load(<span class='m'>Reader</span> writer);
  <span class='b'>void</span> save(<span class='m'>Writer</span> reader);

  <span class='b'>void</span> execute(<span class='m'>String</span>);

  <span class='b'>void</span> addUser(<span class='b'>long</span> id, <span class='m'>String</span> username, <span class='m'>LocalDate</span> signupDate, <span class='m'>String</span> firstName, <span class='m'>String</span> lastName);
  <span class='b'>void</span> addUser(<span class='b'>long</span> id, <span class='m'>String</span> username, <span class='m'>LocalDate</span> signupDate, <span class='m'>String</span> firstName, <span class='m'>String</span> lastName, <span class='m'>LocalDate</span> dateOfBirth);
  <span class='b'>void</span> deleteUser(<span class='b'>long</span> id);

  <span class='m'>String</span> fullName(<span class='b'>long</span> u);
  <span class='b'>long</span>[] usersWhoSignedUpOn(<span class='m'>LocalDate</span> d);
}
</code></pre></section></figure>
</p>

<p>Let's start with the pair of complementary methods <code class='inline-code-box'><span class='inline-code'>load(..)</span></code> and <code class='inline-code-box'><span class='inline-code'>save(..)</span></code>. The latter save a snapshot of the state of the automaton to a <code class='inline-code-box'><span class='inline-code'>java.io.Writer</span></code> object. The state of the automaton is saved in Cell's standard textual format, so that is can be manually inspected and modified. The <code class='inline-code-box'><span class='inline-code'>load(..)</span></code> method, on the other hand, erases the current state of the automaton and loads a new state from the provided <code class='inline-code-box'><span class='inline-code'>java.io.Reader</span></code>, as long as that's a valid state for the automaton in question. The new state must be in the same text format used by the <code class='inline-code-box'><span class='inline-code'>save(..)</span></code> method. If the load operation fails, for whatever reason, the state of the automaton is left unchanged. Loading a previously saved state results in an identical copy of the original automaton, that will pick up where the original left off, and behave in the exact same way.</p>

<p>The next method, <code class='inline-code-box'><span class='inline-code'>execute(..)</span></code>, can be used to send a message to the automaton. The message is provided as a string containing its standard textual representation. If an error occurs during the execution of the message handler an exception is thrown, and the state of the automaton is left unchanged, as already mentioned. This is not the only way to send the automaton a message, as there's a much faster alternative that we'll see in a minute, but having a generic way to send any message in textual form comes in handy in many situations.</p>

<p>Here's an example of how to use the three methods just discussed. The following Java code creates an instance of <code class='inline-code-box'><span class='inline-code'>OnlineForum</span></code>, loads an initial state for it from a file, sends a message to the automaton to delete one specific user from the dataset and saves the resulting state/dataset to another file:</p>

<p><figure class="highlight"><section><pre><code><span class='c'>// Creating an instance of OnlineForum</span>
<span class='m'>OnlineForum</span> onlineForum = new <span class='m'>OnlineForum</span>();

<span class='c'>// Loading the initial state from a file</span>
<span class='k'>try</span> (<span class='m'>FileReader</span> reader = new <span class='m'>FileReader</span>(<span class='s'>&quot;initial-state.txt&quot;</span>)) {
  onlineForum.load(reader);
}

<span class='c'>// Sending a message</span>
onlineForum.execute(<span class='s'>&quot;delete_user(id: user_id(5))&quot;</span>);

<span class='c'>// An equivalent but faster way of sending the exact same message</span>
<span class='c'>// onlineForum.delete_user(5);</span>

<span class='c'>// Writing the new state to a file</span>
<span class='k'>try</span> (<span class='m'>FileWriter</span> writer = new <span class='m'>FileWriter</span>(<span class='s'>&quot;final-state.txt&quot;</span>)) {
  onlineForum.save(writer);
}
</code></pre></section></figure>



</p>

<p>Here's an example of what a valid <a href='online-forum-state.txt'>state</a> for the <code class='inline-code-box'><span class='inline-code'>OnlineForum</span></code> automaton looks like, once it's converted into its standard textual representation.</p>

<p>All the remaining methods are specific to each type of automaton, and they're used to invoke its message handlers and methods. In this specific case, <code class='inline-code-box'><span class='inline-code'>void addUser(..)</span></code> and <code class='inline-code-box'><span class='inline-code'>void deleteUser(long)</span></code> can be used to send the corresponding messages, and in many cases they should be preferred to <code class='inline-code-box'><span class='inline-code'>execute(..)</span></code> since they're much faster, while <code class='inline-code-box'><span class='inline-code'>string fullName(long)</span></code> and <code class='inline-code-box'><span class='inline-code'>long usersWhoSignedUpOn(Date)</span></code> invoke the corresponding (read-only) methods.</p>

<p>The only thing left to mention is the fact that, in order for the generated code to interface smoothly with hand-written Java code, the Cell compiler tries to map each Cell type that appears in the interface of an automaton to a standard Java type or to generate a corresponding Java class for it: in the rare cases in which that fails, the corresponding piece of data is returned or has to be passed in as a string containing the textual representation of the Cell value. The details of the mapping are described in another chapter.</p>


<h3>Auto-generated methods and message handlers</h3>

<p>The Cell compiler can also, if you want it to, automatically generate a number of accessor methods that give you direct access to the data stored inside your automata. It generates methods to read the value of member variables, or the entire content of a relation; to check if a relation contains a given tuple (or element, for unary relations); and finally, in the case of binary relations, to lookup the value of an attribute of a specific entity given its id.</p>

<p>For each automaton there's also a number of message handlers (mainly those that are used to insert data into it, like <code class='inline-code-box'><span class='inline-code'>AddUser</span></code> we saw before) that are almost invariably needed, but whose structure is so predictable that the compiler can generate them automatically. That way, we can avoid polluting the codebase with boring boilerplate code, and leave the developer free to concentrate on the interesting part of the application's logic. Automatic generation of messages and message handlers will be implemented in one of the next versions of the compiler.</p>


<h3>Inheritance hierarchies and polymorphism</h3>

<p>Before we wrap up this introduction, let's take a look at how inheritance hierarchies can be modeled in Cell. As an example, let's say we've to build a very simple payroll system for a company that pays its employees on a weekly basis. Employees are of four types: salaried employees are paid a fixed weekly salary regardless of the number of hours worked, hourly employees are paid by the hour and receive overtime pay (i.e., 1.5 times their hourly salary rate) for all hours worked in excess of 40 hours, commission employees are paid a percentage of their sales and base-salaried commission employees receive a base salary plus a percentage of their sales.</p>

<p>The first step is to create typed identifiers for each of the four types of employees:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>SalariedEmployee</span>   = salaried_employee(<span class='m'>Int</span>);
<span class='k'>type</span> <span class='m'>HourlyEmployee</span>     = hourly_employee(<span class='m'>Int</span>);
<span class='k'>type</span> <span class='m'>CommissionEmployee</span> = commission_employee(<span class='m'>Int</span>);
<span class='k'>type</span> <span class='m'>BasePlusEmployee</span>   = base_plus_employee(<span class='m'>Int</span>);
</section>
</figure>
</code></pre>

<p>The type definitions above are very similar to <code class='inline-code-box'><span class='inline-code'>UserId</span></code> and <code class='inline-code-box'><span class='inline-code'>GroupId</span></code> we saw previously (we just dropped the "Id"/"_id" suffixes). Now we can define the type of all employees:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Employee</span> = <span class='m'>SalariedEmployee</span>,
                <span class='m'>HourlyEmployee</span>,
                <span class='m'>CommissionEmployee</span>,
                <span class='m'>BasePlusEmployee</span>;
</section>
</figure>
</code></pre>

<p><code class='inline-code-box'><span class='inline-code'>Employee</span></code> is just the union of all employee types, in the sense that every value that belongs to one of the four basic types of employees also belongs to <code class='inline-code-box'><span class='inline-code'>Employee</span></code> (types in Cell have set semantics). It's also useful to define the type of all employees that earn commissions:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>AnyCommissionEmployee</span> = <span class='m'>CommissionEmployee</span>, <span class='m'>BasePlusEmployee</span>;
</section>
</figure>
</code></pre>

<p><code class='inline-code-box'><span class='inline-code'>AnyCommissionEmployee</span></code> is obviously a subset/subtype of <code class='inline-code-box'><span class='inline-code'>Employee</span></code>, and the compiler recognizes it as such. The following <code class='inline-code-box'><span class='inline-code'>Workforce</span></code> schema stores basic information about employees:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>schema</span> <span class='m'>Workforce</span> {
  <span class='c'>// Next unused employee id</span>
  next_employee_id : <span class='m'>Int</span> = <span class='n'>0</span>;

  <span class='c'>// Shared attributes of all employees</span>
  employee(<span class='m'>Employee</span>)
    first_name  : <span class='m'>String</span>,
    last_name   : <span class='m'>String</span>,
    ssn         : <span class='m'>String</span>;

  <span class='c'>// Attributes of salaried employees</span>
  employee(<span class='m'>SalariedEmployee</span>)
    weekly_salary : <span class='m'>Money</span>;

  <span class='c'>// Attributes of hourly employees</span>
  employee(<span class='m'>HourlyEmployee</span>)
    hourly_wage  : <span class='m'>Money</span>,
    hours_worked : <span class='m'>Float</span>;

  <span class='c'>// Attributes of all employees that earn commissions,</span>
  <span class='c'>// including those with base salary + commissions</span>
  employee(<span class='m'>AnyCommissionEmployee</span>)
    gross_sales     : <span class='m'>Money</span>,
    commission_rate : <span class='m'>Float</span>;

  <span class='c'>// Attributes of employees with base salary + commissions</span>
  employee(<span class='m'>BasePlusEmployee</span>)
    base_salary : <span class='m'>Money</span>;
}
</section>
</figure>
</code></pre>

<p>The unary relation <code class='inline-code-box'><span class='inline-code'>employee</span></code> contains the identifiers of all employees in the system. The first set of attributes, <code class='inline-code-box'><span class='inline-code'>first_name</span></code>, <code class='inline-code-box'><span class='inline-code'>last_name</span></code> and <code class='inline-code-box'><span class='inline-code'>ssn</span></code>, are common to all types of employees, while others apply only to a specific type: <code class='inline-code-box'><span class='inline-code'>weekly_salary</span></code> is only for salaried employees, <code class='inline-code-box'><span class='inline-code'>hourly_wage</span></code> only for hourly employees, and so on. Finally there's a couple of attributes, <code class='inline-code-box'><span class='inline-code'>gross_sales</span></code> and <code class='inline-code-box'><span class='inline-code'>commission_rate</span></code>, that are shared by all types of employees that can earn commissions.</p>

<p>Now we can define the polymorphic <code class='inline-code-box'><span class='inline-code'>earnings(..)</span></code> method, which is implemented differently for each type of employee:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>using</span> <span class='m'>Workforce</span> {
  <span class='m'>Money</span> earnings(<span class='m'>SalariedEmployee</span> e) = weekly_salary(e);

  <span class='m'>Money</span> earnings(<span class='m'>HourlyEmployee</span> e) {
    hours = hours_worked(e);
    wage = hourly_wage(e);
    earnings = hours * wage;
    earnings = earnings + <span class='n'>0.5</span> * (hours - <span class='n'>40.0</span>) * wage <span class='k'>if</span> hours &gt; <span class='n'>40.0</span>;
    <span class='k'>return</span> earnings;
  }

  <span class='m'>Money</span> earnings(<span class='m'>CommissionEmployee</span> e) =
    commission_rate(e) * gross_sales(e);

  <span class='m'>Money</span> earnings(<span class='m'>BasePlusEmployee</span> e) =
    base_salary(e) + commission_rate(e) * gross_sales(e);
}
</section>
</figure>
</code></pre>

<p>This example is discussed in more depth in another chapter.</p>


<h3>Where to go from here</h3>

<p>It's interesting at this point to implement the data structures and logic of the online forum example in both Cell and Java, in order to see how the two paradigms (functional/relational programming and OOP) compare. You can read about it <a href='comparison.html'>here</a>.</p>

<p>The <a href='relational.html'>relational automata</a> section contains the complete documentation for relational automata, but you'll have to read about <a href='data.html'>data</a> and <a href='types.html'>types</a> first. The <a href='overview.html'>overview</a> will give you some additional high-level information.</p>

<p>This chapter focused on the most important of the two types of automata, namely relational automata. For an overview of the other type, reactive automata, just head to the corresponding <a href='reactive.html'>chapter</a>. It should be readable even without any previous knowledge of the language.</p>


        </article>
      </div>

      <aside id="sidebar">
        <div id='pages'>
          <ul class='toc'>
            <li>Start Here
              <ul class="toc">
                <li><a href='index.html'>Home</a></li>
                <li><a href='overview.html'>Overview</a></li>
                <li><a href='faq.html'>FAQ</a></li>
                <!-- <li><a href='quick.html'>Quick overview</a></li> -->
                <li><a href='example.html'>Introductory example</a></li>
                <li><a href='comparison.html'>A comparison with OOP</a></li>
              </ul>
            </li>
            <li>Rationale
              <ul class="toc">
                <li><a href='relations.html'>Why relations are better than objects</a>
                <!-- <li><a href='state.html'>State</a></li> -->
                <!-- <li><a href='functional.html'>Functional programming</a></li> -->
                <!-- <li><a href='integrity.html'>Encapsulation, equality and data integrity</a></li> -->
              </ul>
            </li>
            <li>Values and Types
              <ul class="toc">
                <li><a href='data.html'>Data</a></li>
                <li><a href='types.html'>Types</a></li>
              </ul>
            </li>
            <li>The Functional Language
              <ul class="toc">
                <li><a href='functions.html'>Functions</a></li>
                <li><a href='imperative.html'>Imperative code</a></li>
                <li><a href='procedures.html'>Procedures</a></li>
                <li><a href='typechecking.html'>Type checking</a></li>
                <li><a href='miscellanea.html'>Protocols, implicit arguments and memoization</a></li>
                <li><a href='benchmarks-functional.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Relational Automata
              <ul class="toc">
                <li><a href='relational.html'>Schemas</a></li>
                <li><a href='data-modeling.html'>Data modeling</a></li>
                <li><a href='methods.html'>Methods</a></li>
                <li><a href='aggregate-functions.html'>Aggregate functions</a></li>
                <li><a href='inheritance.html'>Inheritance and polymorphism</a></li>
                <li><a href='wiring.html'>Wiring automata together</a></li>
                <li><a href='design.html'>Design Process</a></li>
                <li><a href='updates.html'>State updates</a></li>
                <li><a href='using-relational.html'>Using relational automata</a></li>
                <li><a href='benchmarks-relational.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Reactive Automata
              <ul class="toc">
                <li><a href='reactive.html'>Reactive automata</a></li>
                <li><a href='using-reactive.html'>Using reactive automata</a></li>
                <li><a href='reactive-future-work.html'>Future work</a></li>
              </ul>
            </li>
            <li>Interfacing with...
              <ul class="toc">
                <li><a href='interface-cpp.html'>C++</a></li>
                <li><a href='interface-java.html'>Java</a></li>
                <li><a href='interface-cs.html'>C#</a></li>
              </ul>
            </li>
            <li>Network architecture
              <ul class="toc">
                <li><a href='network-architecture.html'>Overview - <strong>NEW</strong></a></li>
              </ul>
            <li>Miscellanea
              <ul class="toc">
                <li><a href='getting-started.html'>Getting started</a></li>
                <li><a href='standard-library.html'>Standard library</a></li>
                <li><a href='status-roadmap.html'>Status and roadmap</a></li>
                <!-- <li><a href='community.html'>Community and contacts</a></li> -->
              </ul>
            </li>

          </ul>
        </div>
      </aside>
    </div>
  </div>
</body>
</html>
