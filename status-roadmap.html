<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta content="width=device-width,initial-scale=1" name="viewport">
  <meta name="description" content="The Cell Programming Language">

  <title>The Cell Programming Language</title>

  <link href="./fonts.css" rel="stylesheet" type="text/css" media="screen">
  <link href="./main.css" rel="stylesheet">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113669835-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113669835-1');
  </script>

</head>

<body>
  <div id="container">

    <header id="topbar">
    </header>

    <div id="main-container">
      <div id="main">
        <article class="content">
<h2>Current status</h2>

<p>The latest version is 0.4.4, and we're still in beta.</p>

<p>More in detail, the functional subset of the language seems now pretty solid. It has been used to write several non-trivial applications, the largest of which is the Cell compiler itself, and no major bugs have been found in almost two years now.</p>

<p>Relational automata are at this point almost complete, in the sense that all major features that are planned for version 1.0 have now been implemented, and performance is already pretty good. They still need more testing though: a lot of major features and under-the-hood improvements have been introduced with the last two releases, and extensive testing will have to wait until after version 0.5.</p>

<p>Reactive automata are at this stage still experimental. Not only they haven't been tested anywhere enough but unlike their relational counterparts their design is still tentative and in a state of flux, and their implementation more complex. They're not expected to come out of beta until after version 1.0.</p>

<p>The documentation on this website is another work in progress. It covers almost all the features of the language, but rational, design guidelines and examples are still incomplete at this stage. And there's no documentation for the standard library yet.</p>


<h3>Road map</h3>

<p>The next version of Cell, 0.5, will finish everything that is still left to do for 1.0, and will be the first release meant for actual use. Apart from a few minor syntactic changes, it will bring improvements to the interface of the generated code, a better support for debugging (right now when a message handler fails, it's hard to figure out exactly what went wrong) and a minimal standard library with documentation. It will also bring back the C++ and C# versions of the compiler (0.2, 0.3 and 0.4 have all been Java-only). Expect the Java code generator in October 2019 and the C# one shortly after that, while the C++ version will be released in the first half of the next year.</p>

<p>Version 0.6 will be the released candidate for 1.0. It won't bring any new features, but it will focus exclusively on testing of relational automata (as explained before, the functional part of the language is already pretty solid, and reactive automata are expected to be still in beta for version 1.0). There's no release date yet.</p>

<p>Version 1.0 will be released once 0.6 has seen enough real world usage and is deemed solid enough to warrant the "1.0" label. That could potentially take a while, but the development of Cell will not stop in the meantime.</p>

<p>One of the first priorities after 0.6 will be the implementation of at least the simplest versions of the network architecture.</p>

<p>There's also a long list of things to do for reactive automata. You can read about them <a href='reactive-future-work.html'>here</a>.</p>

<p>After 1.0 is released, development will focus again on relational automata, and the most important new features will be Datalog-like inference rules with memoization, and more powerful update models. The current update model has clear limitations, but it has a couple of important properties: state transitions are atomic (that is, only the states before and after the transition can be observed, and all intermediate ones are just an implementation detail that is hidden from the developer) and it is amenable to a parallel implementation. The new models will preserve these properties, while adding more flexibility and modularity.</p>


        </article>
      </div>

      <aside id="sidebar">
        <div id='pages'>
          <ul class='toc'>
            <li>Start Here
              <ul class="toc">
                <li><a href='index.html'>Home</a></li>
                <li><a href='overview.html'>Overview</a></li>
                <li><a href='faq.html'>FAQ</a></li>
                <!-- <li><a href='quick.html'>Quick overview</a></li> -->
                <li><a href='example.html'>Introductory example</a></li>
                <li><a href='comparison.html'>A comparison with OOP</a></li>
              </ul>
            </li>
            <li>Rationale
              <ul class="toc">
                <li><a href='relations.html'>Why relations are better than objects</a>
                <!-- <li><a href='state.html'>State</a></li> -->
                <!-- <li><a href='functional.html'>Functional programming</a></li> -->
                <!-- <li><a href='integrity.html'>Encapsulation, equality and data integrity</a></li> -->
              </ul>
            </li>
            <li>Values and Types
              <ul class="toc">
                <li><a href='data.html'>Data</a></li>
                <li><a href='types.html'>Types</a></li>
              </ul>
            </li>
            <li>The Functional Language
              <ul class="toc">
                <li><a href='functions.html'>Functions</a></li>
                <li><a href='imperative.html'>Imperative code</a></li>
                <li><a href='procedures.html'>Procedures</a></li>
                <li><a href='typechecking.html'>Type checking</a></li>
                <li><a href='miscellanea.html'>Protocols, implicit arguments and memoization</a></li>
                <li><a href='benchmarks-functional.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Relational Automata
              <ul class="toc">
                <li><a href='relational.html'>Schemas</a></li>
                <li><a href='data-modeling.html'>Data modeling</a></li>
                <li><a href='methods.html'>Methods</a></li>
                <li><a href='aggregate-functions.html'>Aggregate functions</a></li>
                <li><a href='inheritance.html'>Inheritance and polymorphism</a></li>
                <li><a href='wiring.html'>Wiring automata together</a></li>
                <li><a href='design.html'>Design Process</a></li>
                <li><a href='updates.html'>State updates</a></li>
                <li><a href='using-relational.html'>Using relational automata</a></li>
                <li><a href='benchmarks-relational.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Reactive Automata
              <ul class="toc">
                <li><a href='reactive.html'>Reactive automata</a></li>
                <li><a href='using-reactive.html'>Using reactive automata</a></li>
                <li><a href='reactive-future-work.html'>Future work</a></li>
              </ul>
            </li>
            <li>Interfacing with...
              <ul class="toc">
                <li><a href='interface-cpp.html'>C++</a></li>
                <li><a href='interface-java.html'>Java</a></li>
                <li><a href='interface-cs.html'>C#</a></li>
              </ul>
            </li>
            <li>Miscellanea
              <ul class="toc">
                <li><a href='getting-started.html'>Getting started</a></li>
                <li><a href='status-roadmap.html'>Status and roadmap</a></li>
                <!-- <li><a href='community.html'>Community and contacts</a></li> -->
              </ul>
            </li>

          </ul>
        </div>
      </aside>
    </div>
  </div>
</body>
</html>
