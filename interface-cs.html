<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta content="width=device-width,initial-scale=1" name="viewport">
  <meta name="description" content="The Cell Programming Language">

  <title>The Cell Programming Language</title>

  <link href="./fonts.css" rel="stylesheet" type="text/css" media="screen">
  <link href="./main.css" rel="stylesheet">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113669835-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113669835-1');
  </script>

</head>

<body>
  <div id="container">

    <header id="topbar">
    </header>

    <div id="main-container">
      <div id="main">
        <article class="content">
<h2>Interfacing with C#</h2>

<p>When you compile a Cell program, the compiler does not generate a binary executable. Instead, it generates a number of text files containing code in the chosen output language. We'll examine the C# code generator here. If you define a <code class='inline-code-box'><span class='inline-code'>Main(..)</span></code> procedure in you Cell code, the generated code can then be handed over to a C# compiler to generate an executable file. That's how for instance the Cell compiler itself is built, and also the simplest way to build a program that tests your automata. But if you don't define a <code class='inline-code-box'><span class='inline-code'>Main(..)</span></code> procedure, the compiler will just generate a set of classes, one for each type of automaton in your Cell code, that can be used to instantiate and manipulate the corresponding automata from your C# code. The compiler will produce four files, <code class='inline-code-box'><span class='inline-code'>runtime.cs</span></code>, <code class='inline-code-box'><span class='inline-code'>generated.cs</span></code>, <code class='inline-code-box'><span class='inline-code'>automata.cs</span></code> and <code class='inline-code-box'><span class='inline-code'>typedefs.cs</span></code>. The first one contains the runtime library and the second one the core generated code. The last two files are created only when you don't define a <code class='inline-code-box'><span class='inline-code'>Main(..)</span></code> procedure in the Cell code, and they contain the definition of the classes you'll be working with in your own C# code. <code class='inline-code-box'><span class='inline-code'>automata.cs</span></code> contains the definition of the classes that correspond to the automata defined in your Cell code. The interface of those classes is documented in pseudo-C# in another generated file, <code class='inline-code-box'><span class='inline-code'>automata.txt</span></code>. The purpose of the last file, <code class='inline-code-box'><span class='inline-code'>typedefs.cs</span></code>, will be discussed later.</p>

<p>It's often a good idea not to use the classes in <code class='inline-code-box'><span class='inline-code'>automata.cs</span></code> directly, but to derive your own classes from them, and add new methods (and/or member or class variables, if needed) there. Another slightly more laborious alternative is to write a wrapper class for them. Among other things, if a method of the generated classes requires some sort of manual data conversion, you really don't want to repeatedly perform those conversions all over your codebase: it's much better to have all of them in just one place. The best thing to do is probably to define an overloaded version of the same method, or a similar one, in the derived class, and have it take care of all data conversions before and/or after invoking the generated one.</p>


<h3>Data conversion</h3>

<p>The biggest issue one encounters when interfacing two languages as different as Cell and C# is converting data back and forth between the two native representations. Fortunately, the compiler does most of the heavy lifting for you. For starters, there's a number of simple Cell data types that are mapped directly to a corresponding C# type. They are shown in the following table:</p>

<p><table class="types-table">
  <tr>
    <th>Cell</th>
    <th>C#</th>
  </tr>
  <tr>
    <td>Int</td>
    <td>long</td>
  </tr>
  <tr>
    <td>Float</td>
    <td>double</td>
  </tr>
  <tr>
    <td>Bool</td>
    <td>bool</td>
  </tr>
  <tr>
    <td>String</td>
    <td>string</td>
  </tr>
  <tr>
    <td>Date</td>
    <td>DateTime</td>
  </tr>
  <tr>
    <td>Time</td>
    <td>DateTime</td>
  </tr>
  <tr>
    <td>Symbol</td>
    <td>string</td>
  </tr>
  <tr>
    <td>T*</td>
    <td>T[]</td>
  </tr>
  <tr>
    <td>[T]</td>
    <td>T[]</td>
  </tr>
  <tr>
    <td>[K -> V]</td>
    <td>(K, V)[]</td>
  </tr>
  <tr>
    <td>[T1, T2]</td>
    <td>(T1, T2)[]</td>
  </tr>
  <tr>
    <td>[T1, T2, T3]</td>
    <td>(T1, T2, T3)[]</td>
  </tr>
  <tr>
    <td>(T1, T2, ..)</td>
    <td>(T1, T2, ..)</td>
  </tr>
  <tr>
    <td>(field1: T1, field2: T2, ...)</td>
    <td>(T1 field1, T2 field2, ...)</td>
  </tr>
  <tr>
    <td>any_tag(T)</td>
    <td>T</td>
  </tr>
  <tr>
    <td>Maybe[T]</td>
    <td>T / null</td>
  </tr>
</table>
</p>

<p>The first six entries in the above table are self-explanatory. The mapping for Cell sequences and sets is also straightforward, as both are mapped to C# arrays. For example, the Cell type <code class='inline-code-box'><span class='inline-code'>Int*</span></code> is mapped to <code class='inline-code-box'><span class='inline-code'>long[]</span></code> in C#, and <code class='inline-code-box'><span class='inline-code'>[Date]</span></code> is mapped to <code class='inline-code-box'><span class='inline-code'>DateTime[]</span></code>. Similarly, maps and binary relations are mapped to arrays of 2-tuples, and ternary relations to arrays of 3-tuples. Cell tuples are mapped to tuples in C#, and Cell records to named tuples. The last two entries require a bit of an explanation.</p>

<ul><li>Tagged types can be mapped directly to a C# type only if the tag is a known symbol. In this case, the tag is simply ignored and the mapping of the untagged value is used. A type like <code class='inline-code-box'><span class='inline-code'>&lt;user_id(Int)&gt;</span></code>, for example, will be mapped to a <code class='inline-code-box'><span class='inline-code'>long</span></code> in C#, and the generated code will take care of adding or removing the <code class='inline-code-box'><span class='inline-code'>user_id</span></code> tag as needed.</li><li>The <code class='inline-code-box'><span class='inline-code'>Maybe[T]</span></code> type is mapped directly to the type of its parameter, and the value <code class='inline-code-box'><span class='inline-code'>:nothing</span></code> is mapped to <code class='inline-code-box'><span class='inline-code'>null</span></code>. <code class='inline-code-box'><span class='inline-code'>Maybe[String]</span></code>, for example, is mapped to <code class='inline-code-box'><span class='inline-code'>String</span></code>, and the value <code class='inline-code-box'><span class='inline-code'>:just("Hello!")</span></code> is returned as the C# string <code class='inline-code-box'><span class='inline-code'>"Hello!"</span></code>. Primitive types like <code class='inline-code-box'><span class='inline-code'>long</span></code> or <code class='inline-code-box'><span class='inline-code'>double</span></code> are replaced with the corresponding nullable types: <code class='inline-code-box'><span class='inline-code'>Maybe[Int]</span></code> for example, is mapped to <code class='inline-code-box'><span class='inline-code'>int?</span></code>, and <code class='inline-code-box'><span class='inline-code'>Maybe[Float]</span></code> to <code class='inline-code-box'><span class='inline-code'>double?</span></code>.</li></ul>

<p>Not all types can be handled using the above mapping and that includes important practical cases like polymorphic and recursive types. We'll see how to deal with those more complex types later.</p>


<h3>Relational automata</h3>

<p>Let's now take a look at the classes that are generated when a relational automaton is compiled. We'll make use of a very simple one we've seen before, <code class='inline-code-box'><span class='inline-code'>Counter</span></code>:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>schema</span> <span class='m'>Counter</span> {
  value:   <span class='m'>Int</span> = <span class='n'>0</span>;
  updates: <span class='m'>Int</span> = <span class='n'>0</span>;
}

<span class='m'>Counter</span>.incr {
  <span class='k'>set</span> value = value + <span class='n'>1</span>;
  <span class='k'>set</span> updates = updates + <span class='n'>1</span>;
}

<span class='m'>Counter</span>.decr {
  <span class='k'>set</span> value = value - <span class='n'>1</span>;
  <span class='k'>set</span> updates = updates + <span class='n'>1</span>;
}

<span class='m'>Counter</span>.reset {
  <span class='k'>set</span> value = <span class='n'>0</span>;
  <span class='k'>set</span> updates = updates + <span class='n'>1</span>;
}

<span class='m'>Counter</span>.reset(<span class='m'>Int</span>) {
  <span class='k'>set</span> value = untag(<span class='k'>this</span>);
  <span class='k'>set</span> updates = updates + <span class='n'>1</span>;
}

<span class='k'>using</span> <span class='m'>Counter</span> {
  <span class='m'>Int</span> value   = value;
  <span class='m'>Int</span> updates = updates;

  <span class='m'>Bool</span> is_greater_than(<span class='m'>Int</span> a_value) = value &gt; a_value;

  (value: <span class='m'>Int</span>, updates: <span class='m'>Int</span>) copy_state = (
    value:   value,
    updates: updates
  );
}
</section>
</figure>
</code></pre>

<p>This is the interface of the corresponding C# class generated by the Cell compiler:</p>

<p><figure class="highlight"><section><pre><code><span class='k'>namespace</span> <span class='m'>Cell</span>.<span class='m'>Automata</span> {
  <span class='k'>class</span> <span class='m'>Counter</span> {
    Counter();

    <span class='k'>void</span> Load(<span class='m'>Stream</span>);
    <span class='k'>void</span> Save(<span class='m'>Stream</span>);

    <span class='k'>void</span> Execute(<span class='b'>string</span>);

    <span class='m'>Action</span>&lt;<span class='b'>string</span>&gt; OnSuccess(<span class='b'>string</span>);
    <span class='m'>Action</span>&lt;<span class='b'>string</span>&gt; OnFailure(<span class='b'>string</span>);

    <span class='c'>// Message handlers</span>
    <span class='k'>void</span> Incr();
    <span class='k'>void</span> Decr();
    <span class='k'>void</span> Reset();
    <span class='k'>void</span> Reset(<span class='b'>long</span>);

    <span class='c'>// User-defined methods</span>
    <span class='b'>long</span> Value();
    <span class='b'>long</span> Updates();
    <span class='b'>bool</span> IsGreaterThan(<span class='b'>long</span>);
    (<span class='b'>long</span> value, <span class='b'>long</span> updates) CopyState();
  }
}
</code></pre></section></figure>
</p>

<p>As you can see, the generated C# class has the same name of the Cell automaton it derives from, and is declared in the <code class='inline-code-box'><span class='inline-code'>Cell.Automata</span></code> namespace. The first three methods, <code class='inline-code-box'><span class='inline-code'>Load()</span></code>, <code class='inline-code-box'><span class='inline-code'>Save(..)</span></code> and <code class='inline-code-box'><span class='inline-code'>Execute(..)</span></code>, and the two delegate fields, <code class='inline-code-box'><span class='inline-code'>OnSuccess</span></code> and <code class='inline-code-box'><span class='inline-code'>OnFailure</span></code>, are the same for all relational automata. All other methods are different for each automaton, and are used to send specific types of messages to it or to invoke its (read-only) methods.</p>

<p>The <code class='inline-code-box'><span class='inline-code'>Save(..)</span></code> method is the equivalent of the <code class='inline-code-box'><span class='inline-code'>Save(..)</span></code> procedure in Cell, in that it takes a snapshot of the state of the automaton, which is written to the provided <code class='inline-code-box'><span class='inline-code'>System.IO.Stream</span></code>. The state is saved in the standard text format used for all Cell values.</p>

<p><code class='inline-code-box'><span class='inline-code'>Load(..)</span></code> is used to set the state of an automaton instance, which is read from a <code class='inline-code-box'><span class='inline-code'>System.IO.Stream</span></code>, and is the equivalent of the <code class='inline-code-box'><span class='inline-code'>Load(..)</span></code> procedure in Cell. It can be used at any time in the life of the automaton instance, any number of times. The new state has to be provided in the standard text format. If the provided state is not a valid one, <code class='inline-code-box'><span class='inline-code'>Load(..)</span></code> will throw an exception. In that case, the automaton instance will just retain the state it had before, and will still be perfectly functional.</p>

<p><code class='inline-code-box'><span class='inline-code'>Execute(..)</span></code> is used to send the automaton a message, which has to be passed in text form. A few examples:</p>

<figure class="highlight">
<section>
<pre><code>counter.Execute(<span class='s'>"incr"</span>);
counter.Execute(<span class='s'>"decr"</span>);
counter.Execute(<span class='s'>"reset"</span>);
counter.Execute(<span class='s'>"reset(-1)"</span>);
</section>
</figure>
</code></pre>

<p>Errors handling works in the same way as with <code class='inline-code-box'><span class='inline-code'>Load(..)</span></code>. If an error occurs an exception will be thrown, but the automaton will remain fully operational, and its state will be left untouched.</p>

<p>The next four methods, <code class='inline-code-box'><span class='inline-code'>Incr()</span></code>, <code class='inline-code-box'><span class='inline-code'>Decr()</span></code>, <code class='inline-code-box'><span class='inline-code'>Reset()</span></code> and <code class='inline-code-box'><span class='inline-code'>Reset(long)</span></code> provides another way to send messages to the automaton:</p>

<figure class="highlight">
<section>
<pre><code>counter.Incr();    <span class='c'>// Same as counter.Execute("incr");</span>
counter.Reset(-<span class='n'>1</span>); <span class='c'>// Same as counter.Execute("reset(-1)");</span>
</section>
</figure>
</code></pre>

<p>They are a lot faster than <code class='inline-code-box'><span class='inline-code'>Execute(..)</span></code>, and usually they're more convenient too. There are cases though when the ability to generically send a message of any type to an automaton is crucial, so that's why the compiler provides two ways of doing the same thing.</p>

<p>When updating an automaton instance keep in mind that Cell does not (yet) provide a way to incrementally persist its state: every time you call the <code class='inline-code-box'><span class='inline-code'>Save(..)</span></code> method the entire state of the automaton is saved. That's an expensive operation so typically you'll be performing it only once in a while. That means that you would have unsaved data in memory most of the time, which is of course at risk of being lost in the event of a crash. One simple and efficient way to avoid that is to store the list of messages that were received since the last save. If the application crashes, all you need to do when you restart it is to load the last saved state and re-send all the messages it received after that. That will recreate the exact same state you lost in the crash.</p>

<p>The <code class='inline-code-box'><span class='inline-code'>OnSuccess</span></code> delegate field is meant to help with that. If it's not <code class='inline-code-box'><span class='inline-code'>null</span></code> (which is the initial value) the delegate it points to is called every time a message is processed successfully, and the message itself is passed to it in textual form. The other delegate, <code class='inline-code-box'><span class='inline-code'>OnFailure</span></code>, on the other hand is invoked whenever a message handler fails. Saving those failed messages is not necessary for persistence, but it's typically useful for debugging.</p>

<p>The last four methods, <code class='inline-code-box'><span class='inline-code'>Value()</span></code>, <code class='inline-code-box'><span class='inline-code'>Updates()</span></code>, <code class='inline-code-box'><span class='inline-code'>IsGreaterThan(..)</span></code> and <code class='inline-code-box'><span class='inline-code'>CopyState(..)</span></code>, are just wrappers for the corresponding (read-only) methods of <code class='inline-code-box'><span class='inline-code'>Counter</span></code>.</p>

<p>You can see how in the signatures of the methods of the generated class the types of both arguments and return values are derived using the rules described in the previous paragraph. For example, <code class='inline-code-box'><span class='inline-code'>is_greater_than(..)</span></code> takes an argument of type <code class='inline-code-box'><span class='inline-code'>Int</span></code> and returns a value of type <code class='inline-code-box'><span class='inline-code'>Bool</span></code>, which become <code class='inline-code-box'><span class='inline-code'>long</span></code> and <code class='inline-code-box'><span class='inline-code'>bool</span></code> respectively in C#. Similarly, <code class='inline-code-box'><span class='inline-code'>copy_state</span></code> returns a record in Cell, which is mapped to a named tuple with the same fields in C#, and the types of those fields are in turn mapped from <code class='inline-code-box'><span class='inline-code'>Int</span></code> to <code class='inline-code-box'><span class='inline-code'>long</span></code>.</p>


<h3>More on data conversions</h3>

<p>What happens when the type of an argument or the return value of a method (or message handler) is too complex to be dealt with using the mapping described earlier? Here the default behavior of the compiler is to use the standard textual representation of Cell values as the data exchange format. Let's illustrate this with an example:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Point</span> = point(x: <span class='m'>Int</span>, y: <span class='m'>Int</span>);

<span class='k'>type</span> <span class='m'>Shape</span> = square(left: <span class='m'>Int</span>, bottom: <span class='m'>Int</span>, side: <span class='m'>Nat</span>),
             rectangle(left: <span class='m'>Int</span>, bottom: <span class='m'>Int</span>, width: <span class='m'>Nat</span>, height: <span class='m'>Nat</span>),
             circle(center: <span class='m'>Point</span>, radius: <span class='m'>Int</span>);

<span class='k'>schema</span> <span class='m'>Canvas</span> {
  ...
}

<span class='k'>using</span> <span class='m'>Canvas</span> {
  <span class='m'>Shape</span>* shapes_at(<span class='m'>Point</span> p) = ...
}
</section>
</figure>
</code></pre>

<p>In this example, <code class='inline-code-box'><span class='inline-code'>shapes_at(..)</span></code> return a sequence of values of type <code class='inline-code-box'><span class='inline-code'>Shape</span></code>, which is a polymorphic type. By default the generated <code class='inline-code-box'><span class='inline-code'>Canvas</span></code> class will look like this:</p>

<p><figure class="highlight"><section><pre><code><span class='k'>namespace</span> Cell.Automata {
  <span class='k'>class</span> <span class='m'>Canvas</span> {
    Canvas();

    <span class='k'>void</span> Load(<span class='m'>Stream</span>);
    <span class='k'>void</span> Save(<span class='m'>Stream</span>);

    <span class='k'>string</span>[] ShapesAt((<span class='k'>long</span> x, <span class='k'>long</span> y) p);
  }
}
</code></pre></section></figure>
</p>

<p>As you can see, the return type of <code class='inline-code-box'><span class='inline-code'>ShapesAt(..)</span></code> is <code class='inline-code-box'><span class='inline-code'>string[]</span></code>. Each string in the array is the textual representation of the corresponding Cell value. That is, if <code class='inline-code-box'><span class='inline-code'>shapes_at(..)</span></code> returns the following Cell value:</p>

<figure class="highlight">
<section>
<pre><code>( square(left: <span class='n'>0</span>, bottom: <span class='n'>0</span>, side: <span class='n'>10</span>),
  circle(center: point(x: <span class='n'>8</span>, y: <span class='n'>3</span>), radius: <span class='n'>5</span>),
  rectangle(left: -<span class='n'>25</span>, bottom: <span class='n'>14</span>, width: <span class='n'>4</span>, height: <span class='n'>2</span>)
)
</section>
</figure>
</code></pre>

<p>then the caller of <code class='inline-code-box'><span class='inline-code'>ShapesAt(..)</span></code> on the C# side will get back the following C# object:</p>

<figure class="highlight">
<section>
<pre><code>string[] {
  <span class='s'>"square(left: 0, bottom: 0, side: 10)"</span>,
  <span class='s'>"circle(center: point(x: 8, y: 3), radius: 5)"</span>,
  <span class='s'>"rectangle(left: -25, bottom: 14, width: 4, height: 2)"</span>
}
</section>
</figure>
</code></pre>

<p>Exchanging data in text form is not particularly elegant nor efficient, but it's at least simple and straightforward, and in some cases it works just fine. It tends to work better when passing data from C# to Cell than in the other direction, since strings are easy to generate but difficult to parse.</p>

<p>As an alternative, you can ask the compiler to generate an equivalent C# class for some of the types defined in your Cell code base. What you need to do is create a text file (let's call it types.txt) containing the list of types you want to generate (one type per line). Let's say for instance that you want to generate C# classes for the <code class='inline-code-box'><span class='inline-code'>Point</span></code> and <code class='inline-code-box'><span class='inline-code'>Shape</span></code> types above. The content of types.txt would then look like this:</p>

<p><pre>  Point<br/>  Shape</pre></p>

<p>When you compile your code, you'll have to point the compiler to that file using the <code class='inline-code-box'><span class='inline-code'>-g</span></code> flag:</p>

<p><pre>  cellc-cs -g types.txt &lt;project file&gt;</pre></p>

<p>The interface of the generated <code class='inline-code-box'><span class='inline-code'>Canvas</span></code> class will now look like this:</p>

<p><figure class="highlight"><section><pre><code><span class='k'>namespace</span> Cell.Automata {
  <span class='k'>class</span> <span class='m'>Canvas</span> {
    Canvas();

    <span class='k'>void</span> Load(<span class='m'>Stream</span>);
    <span class='k'>void</span> Save(<span class='m'>Stream</span>);

    <span class='m'>Shape</span>[] ShapesAt((<span class='k'>long</span> x, <span class='k'>long</span> y) p);
  }
}
</code></pre></section></figure>
</p>

<p>As you can see, the return type of <code class='inline-code-box'><span class='inline-code'>ShapesAt(..)</span></code> has now become <code class='inline-code-box'><span class='inline-code'>Shape[]</span></code>. You'll find the definition of <code class='inline-code-box'><span class='inline-code'>Shape</span></code> in the generated <code class='inline-code-box'><span class='inline-code'>typedefs.cs</span></code> file:</p>

<p><figure class="highlight"><section><pre><code><span class='k'>namespace</span> <span class='m'>Cell</span>.<span class='m'>Typedefs</span> {
  <span class='k'>public</span> <span class='k'>partial</span> <span class='k'>class</span> <span class='m'>Point</span> {
    <span class='k'>public</span> <span class='b'>long</span> x;
    <span class='k'>public</span> <span class='b'>long</span> y;

    <span class='k'>public</span> Point(<span class='b'>long</span> x, <span class='b'>long</span> y) {
      this.x = x;
      this.y = y;
    }
  }

  <span class='k'>public</span> <span class='k'>interface</span> <span class='m'>Shape</span> {

  }

  <span class='k'>public</span> <span class='k'>partial</span> <span class='k'>class</span> <span class='m'>Rectangle</span> : <span class='m'>Shape</span> {
    <span class='k'>public</span> <span class='b'>long</span> left;
    <span class='k'>public</span> <span class='b'>long</span> width;
    <span class='k'>public</span> <span class='b'>long</span> bottom;
    <span class='k'>public</span> <span class='b'>long</span> height;

    <span class='k'>public</span> Rectangle(<span class='b'>long</span> left, <span class='b'>long</span> width, <span class='b'>long</span> bottom, <span class='b'>long</span> height) {
      this.left = left;
      this.width = width;
      this.bottom = bottom;
      this.height = height;
    }
  }

  <span class='k'>public</span> <span class='k'>partial</span> <span class='k'>class</span> <span class='m'>Circle</span> : <span class='m'>Shape</span> {
    <span class='k'>public</span> <span class='m'>Point</span> center;
    <span class='k'>public</span> <span class='b'>long</span>  radius;

    <span class='k'>public</span> Circle(<span class='m'>Point</span> center, <span class='b'>long</span> radius) {
      this.center = center;
      this.radius = radius;
    }
  }

  <span class='k'>public</span> <span class='k'>partial</span> <span class='k'>class</span> <span class='m'>Square</span> : <span class='m'>Shape</span> {
    <span class='k'>public</span> <span class='b'>long</span> left;
    <span class='k'>public</span> <span class='b'>long</span> side;
    <span class='k'>public</span> <span class='b'>long</span> bottom;

    <span class='k'>public</span> Square(<span class='b'>long</span> left, <span class='b'>long</span> side, <span class='b'>long</span> bottom) {
      this.left = left;
      this.side = side;
      this.bottom = bottom;
    }
  }
}
</code></pre></section></figure>
</p>

<p>The definition of the <code class='inline-code-box'><span class='inline-code'>Point</span></code> class at the top is straightforward: the type <code class='inline-code-box'><span class='inline-code'>Point</span></code>, which in the Cell codebase is defined as a tagged record with two fields, <code class='inline-code-box'><span class='inline-code'>x</span></code> and <code class='inline-code-box'><span class='inline-code'>y</span></code>, of type <code class='inline-code-box'><span class='inline-code'>Int</span></code>, is mapped to a C# class by the same name with two member variables <code class='inline-code-box'><span class='inline-code'>x</span></code> and <code class='inline-code-box'><span class='inline-code'>y</span></code> of type <code class='inline-code-box'><span class='inline-code'>long</span></code>.</p>

<p>The mapping for <code class='inline-code-box'><span class='inline-code'>Shape</span></code> is a bit more complicated, since that's a polymorphic type. The compiler here has created three classes, <code class='inline-code-box'><span class='inline-code'>Square</span></code>, <code class='inline-code-box'><span class='inline-code'>Rectangle</span></code> and <code class='inline-code-box'><span class='inline-code'>Circle</span></code> each of which corresponds to one of the three alternatives in the <code class='inline-code-box'><span class='inline-code'>Shape</span></code> type definition. <code class='inline-code-box'><span class='inline-code'>Shape</span></code> in C# is defined as an empty interface, which is then implemented by the three concrete classes, so that they can be manipulated polymorphically.</p>

<p>All the classes in <code class='inline-code-box'><span class='inline-code'>typedefs.cs</span></code> are defined as <code class='inline-code-box'><span class='inline-code'>partial</span></code>, which means that you're free to add new methods or member variables to them if need be. You can also directly edit the generated class definitions, as long as you don't change the signature of the generated constructor, and of course the name, namespace and inheritance hierarchy of the generated classes.</p>

<p>Note that at the moment these generated classes are used only when moving data from Cell to C#, but not in the other direction (that is, they're used in the return types of the generated methods, but not in the types of their arguments). For example, the argument of <code class='inline-code-box'><span class='inline-code'>shapes_at(..)</span></code> is of type <code class='inline-code-box'><span class='inline-code'>Point</span></code> in Cell, but its type in the generated <code class='inline-code-box'><span class='inline-code'>ShapesAt(..)</span></code> is <code class='inline-code-box'><span class='inline-code'>(long x, long y)</span></code> rather than <code class='inline-code-box'><span class='inline-code'>Point</span></code>.</p>

<p>In order for the compiler to be able to generate a corresponding C# class for it, a Cell type definition has to obey a number of restrictions. Non-polymorphic types have to be defined as (possibly tagged) records with no optional fields or (possibly tagged) tuples. Any of the following definitions for <code class='inline-code-box'><span class='inline-code'>Point</span></code>, for example, would allow the generation of a corresponding C# class:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Point</span> = (x: <span class='m'>Int</span>, y: <span class='m'>Int</span>);
<span class='k'>type</span> <span class='m'>Point</span> = point(x: <span class='m'>Int</span>, y: <span class='m'>Int</span>);
<span class='k'>type</span> <span class='m'>Point</span> = (<span class='m'>Int</span>, <span class='m'>Int</span>);
<span class='k'>type</span> <span class='m'>Point</span> = point(<span class='m'>Int</span>, <span class='m'>Int</span>);
</section>
</figure>
</code></pre>

<p>but the following ones would not:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Point</span> = (x: <span class='m'>Int</span>, y: <span class='m'>Int</span>, z: <span class='m'>Int</span>?);
<span class='k'>type</span> <span class='m'>Point</span> = point(x: <span class='m'>Int</span>, y: <span class='m'>Int</span>, z: <span class='m'>Int</span>?);
</section>
</figure>
</code></pre>

<p>since the field <code class='inline-code-box'><span class='inline-code'>z</span></code> is optional (in this case though you can achieve the same result by making <code class='inline-code-box'><span class='inline-code'>z</span></code> mandatory and changing its type to <code class='inline-code-box'><span class='inline-code'>Maybe[Int]</span></code>). The rules are even more restrictive for polymorphic types: each alternative in a type union must be a tagged record or tuple, and the tags have to be different. You're free to define each alternative as a separate type though. <code class='inline-code-box'><span class='inline-code'>Shape</span></code> for example could have been defined as follow, without affecting the ability of the compiler to generated a corresponding C# class for it:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Square</span> = square(left: <span class='m'>Int</span>, bottom: <span class='m'>Int</span>, side: <span class='m'>Nat</span>);
<span class='k'>type</span> <span class='m'>Rect</span>   = rectangle(left: <span class='m'>Int</span>, bottom: <span class='m'>Int</span>, width: <span class='m'>Nat</span>, height: <span class='m'>Nat</span>);
<span class='k'>type</span> <span class='m'>Circle</span> = circle(center: <span class='m'>Point</span>, radius: <span class='m'>Int</span>);

<span class='k'>type</span> <span class='m'>Shape</span> = <span class='m'>Square</span>, <span class='m'>Rect</span>, <span class='m'>Circle</span>;
</section>
</figure>
</code></pre>


<h3>Reactive automata</h3>

<p>We'll use <code class='inline-code-box'><span class='inline-code'>Switch</span></code> as our first example. We defined it in a previous chapter as follows:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>reactive</span> <span class='m'>Switch</span> {
  input:
    switch_on  : <span class='m'>Bool</span>;
    switch_off : <span class='m'>Bool</span>;

  output:
    is_on : <span class='m'>Bool</span>;

  state:
    is_on : <span class='m'>Bool</span> = switch_on;

  rules:
    is_on = <span class='k'>true</span>  <span class='k'>when</span> switch_on;
    is_on = <span class='k'>false</span> <span class='k'>when</span> switch_off;
}
</section>
</figure>
</code></pre>

<p>This is the interface of the corresponding C# class:</p>

<p><figure class="highlight"><section><pre><code><span class='k'>namespace</span> <span class='m'>Cell</span>.<span class='m'>Facades</span> {
  <span class='k'>class</span> <span class='m'>Switch</span> {
    <span class='k'>enum</span> <span class='m'>Input</span> {SWITCH_ON, SWITCH_OFF};

    <span class='k'>enum</span> <span class='m'>Output</span> {IS_ON};

    <span class='m'>Switch</span>();

    <span class='b'>void</span> SetInput(<span class='m'>Input</span> input, <span class='b'>string</span> value);
    <span class='b'>string</span> ReadOutput(<span class='m'>Output</span> output);

    <span class='b'>void</span> Apply();
    <span class='b'>string</span> ReadState();
    <span class='b'>void</span> SetState(<span class='b'>string</span>);

    <span class='m'>Output</span>[] ChangedOutputs();

    <span class='c'>// Inputs</span>
    <span class='b'>bool</span> SwitchOn;
    <span class='b'>bool</span> SwitchOff;

    <span class='c'>// Outputs</span>
    <span class='b'>bool</span> IsOn;
  }
}
</code></pre></section></figure>
</p>

<p>The first thing to note here is the two enumerations <code class='inline-code-box'><span class='inline-code'>Input</span></code> and <code class='inline-code-box'><span class='inline-code'>Output</span></code>, whose elements are the uppercase version of the names of the inputs and outputs of <code class='inline-code-box'><span class='inline-code'>Switch</span></code>. These are used in conjunction with the methods <code class='inline-code-box'><span class='inline-code'>SetInput()</span></code> and <code class='inline-code-box'><span class='inline-code'>ReadOutput()</span></code> as shown here:</p>

<p><figure class="highlight">
<section>
<pre><code><span class='c'>// Setting the value of the two inputs</span>
switch.SetInput(<span class='m'>Input</span>.<span class='u'>SWITCH_ON</span>, <span class='s'>"true"</span>);
switch.SetInput(<span class='m'>Input</span>.<span class='u'>SWITCH_OFF</span>, <span class='s'>"false"</span>);

<span class='c'>// Propagating the changes to the inputs</span>
<span class='c'>// throughout the automaton instance</span>
switch.Apply();

<span class='c'>// Reading and printing the value of the only output</span>
string isOn = switch.ReadOutput(<span class='m'>Output</span>.<span class='u'>IS_ON</span>);
Console.WriteLine(<span class='s'>"is_on = {0}"</span>, isOn);
</code></pre></section></figure>
</p>

<p>As an alternative to <code class='inline-code-box'><span class='inline-code'>SetInput(..)</span></code> and <code class='inline-code-box'><span class='inline-code'>ReadOutput(..)</span></code>, which can operate on any input or output and use the textual representation of a value as an exchange format, the generated class also provides another set of methods each of which can manipulate a single input or output, but that are more convenient to use in most cases. The above code snippet can be rewritten as follow:</p>

<p><figure class="highlight">
<section>
<pre><code><span class='c'>// Setting the value of the two inputs</span>
switch.SwitchOn = <span class='k'>true</span>;
switch.SwitchOff = <span class='k'>false</span>;

<span class='c'>// Propagating the changes to the inputs</span>
<span class='c'>// throughout the automaton instance</span>
switch.Apply();

<span class='c'>// Reading and printing the value of the only output</span>
bool isOn = switch.IsOn;
Console.WriteLine(<span class='s'>"is_on = {0}"</span>, isOn);
</code></pre></section></figure>
</p>

<p><code class='inline-code-box'><span class='inline-code'>ReadState()</span></code> takes a snapshot of the state of the automaton and returns it in textual form. <code class='inline-code-box'><span class='inline-code'>SetState(..)</span></code> does the opposite: it sets the state of the automaton to whatever state is passed to it. Here too the new state has to be provided in textual form. When working with time-aware automata both methods are subjects to the limitations that we've already discussed in a previous chapter. The method <code class='inline-code-box'><span class='inline-code'>ChangedOutputs()</span></code> provides a list of outputs that have changed (or have been active, in the case of discrete outputs) as a result of the last call to <code class='inline-code-box'><span class='inline-code'>Apply()</span></code>:</p>

<p><figure class="highlight">
<section>
<pre><code><span class='c'>// Changing inputs here</span>
...

<span class='c'>// Propagating those changes</span>
switch.Apply();

<span class='c'>// Iterating through the outputs that have changed</span>
<span class='c'>// if continuous or have been activated if discrete</span>
<span class='b'>foreach</span> (<span class='b'>var</span> outputId <span class='b'>in</span> switch.ChangedOutputs) {
  <span class='c'>// Reading the value of the changed output</span>
  <span class='b'>string</span> outputValue = switch.ReadOutput(outputId);

  <span class='c'>// Now time to do something with the value of the output</span>
  ...
}
</code></pre></section></figure>
</p>

<p>The last thing we need to see is how to deal with time-aware automata. We'll use <code class='inline-code-box'><span class='inline-code'>WaterSensor</span></code>, whose definition is copied here:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>WaterSensorState</span> = initializing, unknown, submerged(<span class='m'>Bool</span>);

<span class='k'>reactive</span> <span class='m'>WaterSensor</span> raw_reading -&gt; sensor_state {
  input:
    raw_reading* : <span class='m'>Maybe</span>[<span class='m'>Bool</span>];

  output:
    sensor_state : <span class='m'>WaterSensorState</span>;

  state:
    sensor_state : <span class='m'>WaterSensorState</span> = <span class='a'>:initializing</span>;

  rules:
    good_reading := value(raw_reading) <span class='k'>if</span> raw_reading != <span class='a'>:nothing</span>;
    too_long_without_readings = <span class='n'>30s</span> <span class='k'>sans</span> good_reading;
    sensor_state = <span class='a'>:submerged</span>(good_reading);
    sensor_state = <span class='a'>:unknown</span> <span class='k'>when</span> too_long_without_readings;
}
</section>
</figure>
</code></pre>

<p>This is the interface of the generated C# class:</p>

<p><figure class="highlight"><section><pre><code><span class='k'>namespace</span> <span class='m'>Cell</span>.<span class='m'>Facades</span> {
  <span class='k'>interface</span> <span class='m'>WaterSensorState</span> {

  }

  <span class='k'>class</span> <span class='m'>Unknown</span> : <span class='m'>WaterSensorState</span> {
    <span class='k'>static</span> <span class='k'>readonly</span> <span class='m'>Unknown</span> singleton;
  }

  <span class='k'>class</span> <span class='m'>Initializing</span> : <span class='m'>WaterSensorState</span> {
    <span class='k'>static</span> <span class='k'>readonly</span> <span class='m'>Initializing</span> singleton;
  }

  <span class='k'>class</span> <span class='m'>Submerged</span> : <span class='m'>WaterSensorState</span> {
    <span class='b'>bool</span> value;
  }


  <span class='k'>class</span> <span class='m'>WaterSensor</span> {
    <span class='k'>enum</span> <span class='m'>Input</span> {<span class='u'>RAW_READING</span>};

    <span class='k'>enum</span> <span class='m'>Output</span> {<span class='u'>SENSOR_STATE</span>};

    <span class='m'>WaterSensor</span>();

    <span class='b'>void</span> SetInput(<span class='m'>Input</span> input, <span class='b'>string</span> value);
    <span class='b'>string</span> ReadOutput(<span class='m'>Output</span> output);

    <span class='b'>void</span> SetElapsedMillisecs(<span class='b'>int</span>);
    <span class='b'>void</span> SetElapsedSecs(<span class='b'>int</span>);

    <span class='b'>bool</span> Apply();
    <span class='b'>string</span> ReadState();
    <span class='b'>void</span> SetState(<span class='b'>string</span>);

    <span class='m'>Output</span>[] ChangedOutputs();

    <span class='c'>// Inputs</span>
    <span class='b'>bool</span>? RawReading;

    <span class='c'>// Outputs</span>
    <span class='m'>WaterSensorState</span> SensorState;
  }
}
</code></pre></section></figure>
</p>

<p>The only differences here, apart from the input setters and output getters which are obviously specific to each automaton type, are the two extra methods <code class='inline-code-box'><span class='inline-code'>SetElapsedSecs(..)</span></code> and <code class='inline-code-box'><span class='inline-code'>SetElapsedMillisecs(..)</span></code> and the fact that <code class='inline-code-box'><span class='inline-code'>Apply()</span></code> now returns a boolean value. The former are the equivalent of the <code class='inline-code-box'><span class='inline-code'>elapsed</span></code> instruction in Cell, and the value now returned by <code class='inline-code-box'><span class='inline-code'>Apply()</span></code> has the same meaning as the one returned by the <code class='inline-code-box'><span class='inline-code'>apply</span></code> instruction in a Cell procedure. Here's an example of how to update an instance of <code class='inline-code-box'><span class='inline-code'>WaterSensor</span></code>:</p>

<p><figure class="highlight"><section><pre><code><span class='c'>// Updating the values of the inputs here</span>
...

<span class='c'>// Setting the amount of time that has elapsed</span>
<span class='c'>// since the last call to <span class="inline-code">waterSensor.Apply()</span></span>
waterSensor.SetElapsedMillisecs(<span class='n'>100</span>);

<span class='k'>do</span> {
  <span class='c'>// Repeatedly calling <span class="inline-code">Apply()</span> until it returns true</span>
  <span class='c'>// That happens only once all pending timers have</span>
  <span class='c'>// been processed and the changes in the values of</span>
  <span class='c'>// the inputs propagated throughout the automaton</span>
  <span class='b'>bool</span> done = waterSensor.Apply();

  <span class='c'>// Iterating through the outputs that have changed</span>
  <span class='c'>// if countinuous or have been activated if discrete</span>
  <span class='k'>foreach</span> (<span class='k'>var</span> outputId <span class='k'>in</span> waterSensor.ChangedOutputs) {
    <span class='c'>// Reading the value of the changed output</span>
    <span class='m'>Value</span> outputValue = waterSensor.ReadOutput(outputId);

    <span class='c'>// Now time to do something with the value of the output</span>
    ...
  }
} <span class='k'>while</span> (!done);
</code></pre></section></figure>
</p>


        </article>
      </div>

      <aside id="sidebar">
        <div id='pages'>
          <ul class='toc'>
            <li>Start Here
              <ul class="toc">
                <li><a href='index.html'>Home</a></li>
                <li><a href='overview.html'>Overview</a></li>
                <li><a href='faq.html'>FAQ</a></li>
                <!-- <li><a href='quick.html'>Quick overview</a></li> -->
                <li><a href='example.html'>Introductory example</a></li>
                <li><a href='comparison.html'>A comparison with OOP</a></li>
              </ul>
            </li>
            <li>Rationale
              <ul class="toc">
                <li><a href='relations.html'>Why relations are better than objects</a>
                <!-- <li><a href='state.html'>State</a></li> -->
                <!-- <li><a href='functional.html'>Functional programming</a></li> -->
                <!-- <li><a href='integrity.html'>Encapsulation, equality and data integrity</a></li> -->
              </ul>
            </li>
            <li>Values and Types
              <ul class="toc">
                <li><a href='data.html'>Data</a></li>
                <li><a href='types.html'>Types</a></li>
              </ul>
            </li>
            <li>The Functional Language
              <ul class="toc">
                <li><a href='functions.html'>Functions</a></li>
                <li><a href='imperative.html'>Imperative code</a></li>
                <li><a href='procedures.html'>Procedures</a></li>
                <li><a href='typechecking.html'>Type checking</a></li>
                <li><a href='miscellanea.html'>Protocols, implicit arguments and memoization</a></li>
                <li><a href='benchmarks-functional.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Relational Automata
              <ul class="toc">
                <li><a href='relational.html'>Schemas</a></li>
                <li><a href='data-modeling.html'>Data modeling</a></li>
                <li><a href='methods.html'>Methods</a></li>
                <li><a href='aggregate-functions.html'>Aggregate functions</a></li>
                <li><a href='inheritance.html'>Inheritance and polymorphism</a></li>
                <li><a href='wiring.html'>Wiring automata together</a></li>
                <li><a href='design.html'>Design Process</a></li>
                <li><a href='updates.html'>State updates</a></li>
                <li><a href='using-relational.html'>Using relational automata</a></li>
                <li><a href='benchmarks-relational.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Reactive Automata
              <ul class="toc">
                <li><a href='reactive.html'>Reactive automata</a></li>
                <li><a href='using-reactive.html'>Using reactive automata</a></li>
                <li><a href='reactive-future-work.html'>Future work</a></li>
              </ul>
            </li>
            <li>Embedded use
              <ul class="toc">
                <li><a href='interface-cpp.html'>C++</a></li>
                <li><a href='interface-java.html'>Java</a></li>
                <li><a href='interface-cs.html'>C#</a></li>
              </ul>
            </li>
            <li>Network architecture
              <ul class="toc">
                <li><a href='network-architecture.html'>Overview</a></li>
              </ul>
            <li>Miscellanea
              <ul class="toc">
                <li><a href='getting-started.html'>Getting started</a></li>
                <li><a href='standard-library.html'>Standard library</a></li>
                <li><a href='status-roadmap.html'>Status and roadmap</a></li>
                <!-- <li><a href='community.html'>Community and contacts</a></li> -->
              </ul>
            </li>

          </ul>
        </div>
      </aside>
    </div>
  </div>
</body>
</html>
