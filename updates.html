<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta content="width=device-width,initial-scale=1" name="viewport">
  <meta name="description" content="The Cell Programming Language">

  <title>The Cell Programming Language</title>

  <link href="./fonts.css" rel="stylesheet" type="text/css" media="screen">
  <link href="./main.css" rel="stylesheet">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113669835-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113669835-1');
  </script>

</head>

<body>
  <div id="container">

    <header id="topbar">
    </header>

    <div id="main-container">
      <div id="main">
        <article class="content">
<h2>Message handlers and updates</h2>

<p>The normal way to mutate the state of an automaton is to send it a message. For each type of message there's a corresponding message handler which is just a block of imperative code that takes the message itself as argument and carries out the actual update. Here's an example, using the <code class='inline-code-box'><span class='inline-code'>Counter</span></code> automaton that we defined earlier:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>schema</span> <span class='m'>Counter</span> {
  value:   <span class='m'>Int</span> = <span class='n'>0</span>;
  updates: <span class='m'>Int</span> = <span class='n'>0</span>;
}

<span class='c'>// type CounterMsg = incr, decr, reset, reset(Int);</span>

<span class='m'>Counter</span>.incr {
  set value = value + <span class='n'>1</span>;
  set updates = updates + <span class='n'>1</span>;
}

<span class='m'>Counter</span>.decr {
  set value = value - <span class='n'>1</span>;
  set updates = updates + <span class='n'>1</span>;
}

<span class='m'>Counter</span>.reset {
  set value = <span class='n'>0</span>;
  set updates = updates + <span class='n'>1</span>;
}

<span class='m'>Counter</span>.reset(<span class='m'>Int</span>) {
  set value = untag(<span class='k'>this</span>);
  set updates = updates + <span class='n'>1</span>;
}
</section>
</figure>
</code></pre>

<p>The <code class='inline-code-box'><span class='inline-code'>CounterMsg</span></code> type defines the set of messages <code class='inline-code-box'><span class='inline-code'>Counter</span></code> can accept. The declaration is commented out because it's actually unnecessary, it's basically just documentation. After that are four message handlers: the first three handle the values <code class='inline-code-box'><span class='inline-code'>:incr</span></code>, <code class='inline-code-box'><span class='inline-code'>:decr</span></code> and <code class='inline-code-box'><span class='inline-code'>:reset</span></code> respectively, and the last one all integers tagged with the <code class='inline-code-box'><span class='inline-code'>:reset</span></code> symbol. They all make use of some syntactic sugar: the general, unsweetened form of a message handler is as follows:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>AutomatonType</span>.<span class='m'>MessageType</span> {
  ...
}
</section>
</figure>
</code></pre>

<p>so without any syntactic sugar, the first of those message handlers would have to be written like this:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>IncrCounterMsg</span> = incr;

<span class='m'>Counter</span>.<span class='m'>IncrCounterMsg</span> {
  set value = value + <span class='n'>1</span>;
  set updates = updates + <span class='n'>1</span>;
}
</section>
</figure>
</code></pre>

<p>or more simply like this:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>Counter</span>.&lt;incr&gt; {
  set value = value + <span class='n'>1</span>;
  set updates = updates + <span class='n'>1</span>;
}
</section>
</figure>
</code></pre>

<p>but in the latter case you're allowed to ommit the <code class='inline-code-box'><span class='inline-code'>&lt;</span></code> and <code class='inline-code-box'><span class='inline-code'>&gt;</span></code> symbols, if the type between them is not a union type. In order to access the value of the message you need to use the keyword <code class='inline-code-box'><span class='inline-code'>this</span></code>, as demonstrated in the last handler, <code class='inline-code-box'><span class='inline-code'>Counter.reset(Int)</span></code>. Note that the same keyword is also used in several object-oriented languages, but the meaning is different: in OOP it's used to refer to the target of a method (that is, the object that "receives the message") while here it's used to refer to the message itself. There's no way in this context to refer to (the value of) the automaton instance that receives the message (only its individual fields can be accessed), because that value cannot be aliased as we explained in the previous chapters.</p>

<p>Any number of message handlers can be merged without restrictions, whenever that's convenient. The four message handlers of <code class='inline-code-box'><span class='inline-code'>Counter</span></code> can for example be rewritten as follow:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>CounterMsg</span> = incr, decr, reset, reset(<span class='m'>Int</span>);

<span class='m'>Counter</span>.<span class='m'>CounterMsg</span> {
  new_value = <span class='k'>match</span> (<span class='k'>this</span>)
    incr      = value + <span class='n'>1</span>,
    decr      = value - <span class='n'>1</span>,
    reset     = <span class='n'>0</span>,
    reset(n?) = n;
  set value = new_value;
  set updates = updates + <span class='n'>1</span>;
}
</section>
</figure>
</code></pre>

<p>or alternatively like this:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>Counter</span>.<span class='m'>CounterMsg</span> {
  set value = new_value(<span class='k'>this</span>);
  set updates = updates + <span class='n'>1</span>;
}

<span class='k'>using</span> <span class='m'>Counter</span> {
  <span class='m'>Int</span> new_value(<span class='m'>CounterMsg</span> msg) =
    incr      = value + <span class='n'>1</span>,
    decr      = value - <span class='n'>1</span>,
    reset     = <span class='n'>0</span>,
    reset(n?) = n;
}
</section>
</figure>
</code></pre>

<p>All three implementations are completely equivalent.</p>

<p>In spite of a few superficial similarities, message handlers differ from methods in OOP (or even messages in the actor model) in several significant ways:</p>

<ul><li>Similarily to messages in the actor model, but unlike methods in OOP, messages in Cell are just ordinary values, that can be manipulated like any other piece of data: they can be copied, passed around, sent over a network and saved to a file. It's very easy, for instance, to store and keep a record of all messages that have been received by any given automaton instance.</li><li>Another similarity with the actor model is that message handlers don't return a value: there's a strict separation between commands/messages and queries/methods. Such a programming model is more reliable when writing distributed applications.</li><li>Automata can only receive messages, not send them, even to themselves. There's no such thing as "message passing" between automata. That's by design and it's never going to change: automata are meant to be self-contained entities, oblivious to the world around them, the only exception being other automata they're wired to. Any inter-automata update logic there is, it has to go somewhere else. For the time being, that typically means it has to be dealt with in the host language, not in Cell. There's only one exception to this, and it's an important one: a message handler can send a message to the dependees of the current automaton.</li><li>The scope of the side effects caused by a message handler is limited to the automaton instance that received the message and its dependees. The state of other automata is not affected, and that includes the dependants of the target of the message.</li><li>All update instructions that are issued as part of the execution of a message handler do not take effect immediately. Instead, they are retained and applied only when the message handler returns, which means that during the entire execution of the latter the state of the automaton doesn't change at all. Not only that, but also the specific order in which those commands are issued is ignored. This is a major difference, that completely changes the way you have to write and think about update code. It comes with a long list of trade-offs, which we'll discuss in detail later.</li></ul>


<h3>Atomic update instructions</h3>

<p>We've already seen our first atomic update instruction, the <code class='inline-code-box'><span class='inline-code'>set</span></code> statement, which simply sets the value of a member variable. It can be used only with ordinary variables, not with mutable relation variables. The most important thing to notice here is that any given member variable can be assigned only once during the execution of the message handler: trying to set the same variable twice would cause the message handler to fail. That's because, as explained above, the order in which assignments are issued is ignored, and therefore there's no way to decide which of two (conflicting) assignments targeting the same member variable should actually be executed.</p>

<p>In order to update mutable relation variables the language provides two commands, <code class='inline-code-box'><span class='inline-code'>insert</span></code> and <code class='inline-code-box'><span class='inline-code'>delete</span></code>. To illustrate them, we'll make use of some of the automata we defined in the previous chapter. Here's our first example:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>schema</span> <span class='m'>Logins</span> {
  usernames(<span class='m'>Nat</span>, <span class='m'>String</span>) [<span class='k'>key</span>: <span class='n'>0</span>, <span class='k'>key</span>: <span class='n'>1</span>];
  memberships(<span class='m'>Nat</span>, <span class='m'>String</span>);
}

<span class='m'>Logins</span>.login(user_id: <span class='m'>Nat</span>, name: <span class='m'>String</span>) {
  <span class='c'>// Inserting the entry <span class='inline-code'>this.user_id, this.name</span> into <span class='inline-code'>usernames</span></span>
  <span class='c'>// No effect if <span class='inline-code'>usernames</span> already contains such an entry</span>
  <span class='c'>// Fails if a (different) entry with the same left argument or</span>
  <span class='c'>// the same right argument (but not both) already exists, since</span>
  <span class='c'>// that would violate the integrity constraints of <span class='inline-code'>usernames</span></span>
  <span class='k'>insert</span> usernames(<span class='k'>this</span>.user_id, <span class='k'>this</span>.name);
}

<span class='m'>Logins</span>.logout(user_id: <span class='m'>Nat</span>) {
  <span class='c'>// Deleting all entries whose left field equals <span class='inline-code'>this.user_id</span></span>
  <span class='c'>// from both <span class='inline-code'>usernames</span> and <span class='inline-code'>memberships</span></span>
  <span class='k'>delete</span> usernames(<span class='k'>this</span>.user_id, *), memberships(<span class='k'>this</span>.user_id, *);
}

<span class='m'>Logins</span>.join_room(user_id: <span class='m'>Nat</span>, room: <span class='m'>String</span>) {
  <span class='c'>// Inserting the entry <span class='inline-code'>this.user_id, this.room</span> into <span class='inline-code'>memberships</span></span>
  <span class='c'>// No effect if <span class='inline-code'>memberships</span> already contains such an entry</span>
  <span class='k'>insert</span> memberships(<span class='k'>this</span>.user_id, <span class='k'>this</span>.room);
}

<span class='m'>Logins</span>.leave_room(user_id: <span class='m'>Nat</span>, room: <span class='m'>String</span>) {
  <span class='c'>// Deleting the entry <span class='inline-code'>this.user_id, this.room</span> from <span class='inline-code'>memberships</span>,</span>
  <span class='c'>// if such entry exists, no effect otherwise</span>
  <span class='k'>delete</span> memberships(<span class='k'>this</span>.user_id, <span class='k'>this</span>.room);
}

<span class='m'>Logins</span>.clear {
  <span class='c'>// Deleting all entries from both <span class='inline-code'>usernames</span> and <span class='inline-code'>memberships</span></span>
  <span class='k'>delete</span> usernames(*, *), memberships(*, *);
}
</section>
</figure>
</code></pre>

<p>For both updates and deletes you can merge several commands into a single one: <code class='inline-code-box'><span class='inline-code'>insert relvar1(x1, y1);</span></code> and <code class='inline-code-box'><span class='inline-code'>insert relvar2(x2, y2);</span></code> can be combined, with no difference in meaning, into <code class='inline-code-box-long'><span class='inline-code'>insert relvar1(x1, y1), relvar2(x2, y2);</span></code>. When deleting entries you can also use wildcard arguments, as demonstrated in <code class='inline-code-box'><span class='inline-code'>Logins.logout(..)</span></code> and <code class='inline-code-box'><span class='inline-code'>Logins.clear</span></code>. The above examples all use binary relation variables, but it all works in the same way for unary and ternary ones, just with one or three arguments respectively instead of two.</p>

<p>The <code class='inline-code-box'><span class='inline-code'>insert</span></code> command comes in two flavors. The standard version is the one shown in the above example: it fails when inserting an entry that would violate the integrity constraints that apply to the target relation variable. The second form is a sort of "forced insert": if the relation contains entries that are key-incompatible with the entry that is being inserted the former are simply deleted. The only syntactic difference is that it requires the <code class='inline-code-box'><span class='inline-code'>update</span></code> keyword instead of <code class='inline-code-box'><span class='inline-code'>insert</span></code>. A command of the form:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>update</span> usernames(id, name);
</section>
</figure>
</code></pre>

<p>is (in the specific case of <code class='inline-code-box'><span class='inline-code'>usernames</span></code>, which has a key on both columns) equivalent to:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>delete</span> usernames(id, *);
<span class='k'>delete</span> usernames(*, name);
<span class='k'>insert</span> usernames(id, name);
</section>
</figure>
</code></pre>

<p>For relations that have no keys, like <code class='inline-code-box'><span class='inline-code'>memberships</span></code>, the two forms are completely equivalent. The <code class='inline-code-box'><span class='inline-code'>update</span></code> form is convenient when updating the values of the attributes of an existing entity or relationship (hence its name): this is, for instance, how you would update the value of the <code class='inline-code-box'><span class='inline-code'>address</span></code> attribute for a specific supplier in the <code class='inline-code-box'><span class='inline-code'>Supply</span></code> automaton defined in the previous chapter:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>Supply</span>.set_address(supplier_id: <span class='m'>SupplierId</span>, new_address: <span class='m'>String</span>) {
  <span class='k'>update</span> address(<span class='k'>this</span>.supplier_id, <span class='k'>this</span>.new_address);
  <span class='c'>// The above statement is equivalent to:</span>
  <span class='c'>// delete address(this.supplier_id, *);</span>
  <span class='c'>// insert address(this.supplier_id, this.new_address);</span>
}
</section>
</figure>
</code></pre>

<p>or the price charged by a specific supplier for a specific part:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>Supply</span>.set_price(suppl_id: <span class='m'>SupplierId</span>, part_id: <span class='m'>PartId</span>, price: <span class='m'>Money</span>) {
  <span class='k'>update</span> unit_price(<span class='k'>this</span>.suppl_id, <span class='k'>this</span>.part_id, <span class='k'>this</span>.price);
  <span class='c'>// The above statement is equivalent to:</span>
  <span class='c'>// delete unit_price(this.suppl_id, this.part_id, *);</span>
  <span class='c'>// insert unit_price(this.suppl_id, this.part_id, this.price);</span>
}
</section>
</figure>
</code></pre>

<p>Just like it happens with the <code class='inline-code-box'><span class='inline-code'>set</span></code> instruction, the order in which inserts, updates and deletes are issued is ignored, so you have to take care not to issue conflicting commands. These update handlers, for instance, will fail:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>Logins</span>.bad_update_1 {
  <span class='c'>// Fails because it violates the key</span>
  <span class='c'>// on the first column of usernames</span>
  <span class='k'>insert</span> usernames(<span class='n'>0</span>, <span class='s'>"tom"</span>);
  <span class='k'>insert</span> usernames(<span class='n'>0</span>, <span class='s'>"peter"</span>);
}

<span class='m'>Logins</span>.bad_update_2 {
  <span class='c'>// Fails because it violates the key</span>
  <span class='c'>// on the second column of usernames</span>
  <span class='k'>insert</span> usernames(<span class='n'>0</span>, <span class='s'>"jack"</span>);
  <span class='k'>insert</span> usernames(<span class='n'>1</span>, <span class='s'>"jack"</span>);
}
</section>
</figure>
</code></pre>

<p>Inserting the exact same entry twice will always succeed though, because duplicates are ignored:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>Logins</span>.redundant_update {
  <span class='c'>// Succeeds because the two insertions are</span>
  <span class='c'>// not incompatible, just redundant</span>
  <span class='k'>insert</span> usernames(<span class='n'>10</span>, <span class='s'>"sarah"</span>);
  <span class='k'>insert</span> usernames(<span class='n'>10</span>, <span class='s'>"sarah"</span>);
}
</section>
</figure>
</code></pre>

<p>Once the message handler returns and all inserts and deletes take effect, the order in which these commands are issued is irrelevant but, conceptually at least, all deletes are applied before the inserts. Updates commands are just treated as a combination of deletes and inserts.</p>


<h3>Inserting attributes</h3>

<p>When inserting an entity or a relationship from a dataset you'll generally have to also insert attributes stored in ancillary relations. That tends to be rather very verbose, so the language provides some syntactic sugar here. If you have a set of mutable relation variables like the following ones:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>schema</span> <span class='m'>Users</span> {
  user(<span class='m'>UserId</span>)
    name            : <span class='m'>String</span>, <span class='c'>// Mandatory</span>
    date_of_birth?  : <span class='m'>Date</span>,   <span class='c'>// Optional</span>
    phone_number+   : <span class='m'>String</span>; <span class='c'>// One or more values</span>

  ...
}
</section>
</figure>
</code></pre>

<p>Here's how you can write a message handlers that inserts a new user and all its attributes:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>User</span>.add_user(id: <span class='m'>UserId</span>, name: <span class='m'>String</span>, date: <span class='m'>Date</span>, phone: <span class='m'>String</span>) {
  <span class='k'>insert</span> user(<span class='k'>this</span>.id)
    name          = <span class='k'>this</span>.name,
    date_of_birth = <span class='k'>this</span>.date,
    phone_number  = <span class='k'>this</span>.phone;
}
</section>
</figure>
</code></pre>

<p>It's completely equivalent to the following, more verbose version:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>User</span>.add_user(id: <span class='m'>UserId</span>, name: <span class='m'>String</span>, date: <span class='m'>Date</span>, phone: <span class='m'>String</span>) {
  <span class='k'>insert</span> user(<span class='k'>this</span>.id);
  <span class='k'>insert</span> name(<span class='k'>this</span>.id, <span class='k'>this</span>.name);
  <span class='k'>insert</span> date_of_birth(<span class='k'>this</span>.id, <span class='k'>this</span>.date);
  <span class='k'>insert</span> phone(<span class='k'>this</span>.id, <span class='k'>this</span>.phone);
}
</section>
</figure>
</code></pre>

<p>Here's another, more complex example:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>User</span>.add_user(id: <span class='m'>UserId</span>, name: <span class='m'>String</span>, date: <span class='m'>Date</span>?, phones: [+<span class='m'>String</span>]) {
  <span class='k'>insert</span> user(<span class='k'>this</span>.id)
    name          = <span class='k'>this</span>.name,
    date_of_birth = <span class='k'>this</span>.date <span class='k'>if</span> <span class='k'>this</span>.date?,
    phone_number  = p : p &lt;- <span class='k'>this</span>.phones;
}
</section>
</figure>
</code></pre>

<p>which is equivalent to:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>User</span>.add_user(id: <span class='m'>UserId</span>, name: <span class='m'>String</span>, date: <span class='m'>Date</span>?, phones: [+<span class='m'>String</span>]) {
  <span class='k'>insert</span> user(<span class='k'>this</span>.id);
  <span class='k'>insert</span> name(<span class='k'>this</span>.id, <span class='k'>this</span>.name);
  <span class='k'>if</span> <span class='k'>this</span>.date?
    <span class='k'>insert</span> date_of_birth(<span class='k'>this</span>.id, <span class='k'>this</span>.date);
  <span class='k'>for</span> p &lt;- <span class='k'>this</span>.phones
    <span class='k'>insert</span> phone(<span class='k'>this</span>.id, p);
}
</section>
</figure>
</code></pre>

<p>Whenever you insert a new entity or relationship in the dataset, the compiler checks that you're also inserting all its mandatory attributes. More specifically, whenever you define, either implicitly or explicitly, a foreign key like this:</p>

<figure class="highlight">
<section>
<pre><code>unary_rel(x) -&gt; binary_rel(x, _);
</section>
</figure>
</code></pre>

<p>the compilers expects you to follow up any insertion into <code class='inline-code-box'><span class='inline-code'>unary_rel</span></code> with a corresponding one in <code class='inline-code-box'><span class='inline-code'>binary_rel</span></code>, and for a foreign key of the type:</p>

<figure class="highlight">
<section>
<pre><code>binary_rel(x, y) -&gt; ternary_rel(x, y, _);
</section>
</figure>
</code></pre>

<p>it expects any insertion into <code class='inline-code-box'><span class='inline-code'>binary_rel</span></code> to be followed by at least one insertion into <code class='inline-code-box'><span class='inline-code'>ternary_rel</span></code>. In both cases it makes sure that you're inserting exactly one value for (mandatory) single-valued attributes, and at least one for (mandatory) multi-valued ones.</p>


<h3>Cascade deletes</h3>

<p>Just like for insertions, there's some syntactic sugar for deletions as well. Using the <code class='inline-code-box'><span class='inline-code'>Users</span></code> schema defined above, the following message handler:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>Users</span>.delete_user(id: <span class='m'>UserId</span>) {
  <span class='k'>delete</span> user(<span class='k'>this</span>.id);
}
</section>
</figure>
</code></pre>

<p>not only deletes that particular id from <code class='inline-code-box'><span class='inline-code'>user</span></code>, but also deletes all its corresponding entries in the attribute relations. In other words, the compiler rewrites the body of <code class='inline-code-box'><span class='inline-code'>delete_user()</span></code> like so:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>Users</span>.delete_user(id: <span class='m'>UserId</span>) {
  <span class='k'>delete</span> user(<span class='k'>this</span>.id);
  <span class='k'>delete</span> name(<span class='k'>this</span>.id, *);
  <span class='k'>delete</span> date_of_birth(<span class='k'>this</span>.id, *);
  <span class='k'>delete</span> phone_number(<span class='k'>this</span>.id, *);
}
</section>
</figure>
</code></pre>

<p>Note, though, that only the attributes that are defined using the syntactic sugar are deleted automatically. If <code class='inline-code-box'><span class='inline-code'>Users</span></code> had been defined as follows, without any syntactic sugar:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>schema</span> <span class='m'>Users</span> {
  user(<span class='m'>UserId</span>);
  user(u) -&gt; name(u, _), phone_number(u, _);

  name(<span class='m'>UserId</span>, <span class='m'>String</span>) [<span class='k'>key</span>: <span class='n'>0</span>];
  name(u, _) -&gt; user(u);

  date_of_birth(<span class='m'>UserId</span>, <span class='m'>Date</span>) [<span class='k'>key</span>: <span class='n'>0</span>];
  date_of_birth(u, _) -&gt; user(u);

  phone_number(<span class='m'>UserId</span>, <span class='m'>String</span>);
  phone_number(u, _) -&gt; user(u);

  ...
}
</section>
</figure>
</code></pre>

<p>you would have had to explicitly delete all the data from the attribute relations as well.</p>


<h3>Mutator methods</h3>

<p>Message handlers have no way to invoke one another (or to put it another way, automata cannot send messages to themselves), so when you need to share code between them or split their implementation in smaller, more manageable chunks, you need to make use of another construct, mutator methods. The following is yet another way to implement the message handlers of <code class='inline-code-box'><span class='inline-code'>Counter</span></code>:</p>

<figure class="highlight">
<section>
<pre><code><span class='m'>Counter</span>.incr {
  update_value(value + <span class='n'>1</span>);
}

<span class='m'>Counter</span>.decr {
  update_value(value - <span class='n'>1</span>);
}

<span class='m'>Counter</span>.reset {
  update_value(<span class='n'>0</span>);
}

<span class='m'>Counter</span>.reset(<span class='m'>Int</span>) {
  update_value(untag(<span class='k'>this</span>));
}

<span class='k'>using</span> <span class='m'>Counter</span> {
  update_value(<span class='m'>Int</span> new_value) {
    set value = new_value;
    set updates = updates + <span class='n'>1</span>;
  }
}
</section>
</figure>
</code></pre>

<p>Now each message handler just calculates the new value for <code class='inline-code-box'><span class='inline-code'>value</span></code>, which is then passed on to the mutator method <code class='inline-code-box'><span class='inline-code'>update_value(..)</span></code> which issues the commands needed to update both <code class='inline-code-box'><span class='inline-code'>value</span></code> and <code class='inline-code-box'><span class='inline-code'>updates</span></code>. Mutator methods must be declared inside a using block, have no return value, can take any number of arguments and can be polymorphich just like functions and ordinary read-only methods. They can be invoked only from message handlers and other mutator methods of the same automaton.</p>

<p>In order to better understand the respective roles of message handlers and mutator methods and the differences between them it's useful to review the life cycle of an update. Once an automaton receives a message, the corresponding handler is invoked. A message handler is the entry point for any update to any relational automaton: an update starts when a handler is invoked, and finishes when the handler returns, after which the state of the automaton is finally updated. Until the handler returns no other handler can be invoked, and therefore no other message can be received: the execution of two message handlers of the same automaton cannot be interleaved or nested, message handlers cannot invoke each other in any way, and automata cannot send messages to themselves. Mutators on the other hand can only be run as part of the execution of a message handler, and cannot be invoked in any other context. The update commands they issue are only applied when their enclosing handler returns, and if they fail they cause the entire handler to fail. Message handlers can only be invoked from the outside, and they constitute the public interface of relational automata with regards to updates, while mutators are only meant to provide a way to implement message handlers in a modular way.</p>


<h3>Wired automata</h3>

<p>As already explained, automata are passive entities that can only receive but not send messages, with one exception: the body of a message handler can send a message to the dependees of the current automaton. Here's an example, extending something we saw in a previous chapter:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>schema</span> <span class='m'>Logins</span> {
  usernames(<span class='m'>Nat</span>, <span class='m'>String</span>) [<span class='k'>key</span>: <span class='n'>0</span>, <span class='k'>key</span>: <span class='n'>1</span>];
  memberships(<span class='m'>Nat</span>, <span class='m'>String</span>);
}

<span class='m'>Logins</span>.remove_user(id: <span class='m'>Nat</span>) {
  <span class='k'>delete</span> usernames(<span class='k'>this</span>.id, *), memberships(<span class='k'>this</span>.id, *);
}

<span class='k'>schema</span> <span class='m'>ChatServer</span> : <span class='m'>Logins</span> {
  connected_users(<span class='m'>Nat</span>);
}

<span class='m'>ChatServer</span>.disconnect(id: <span class='m'>Nat</span>) {
  <span class='k'>delete</span> connected_users(<span class='k'>this</span>.id);
  <span class='k'>super</span> &lt;- remove_user(id: <span class='k'>this</span>.id);
}
</section>
</figure>
</code></pre>

<p>Just as before, <code class='inline-code-box'><span class='inline-code'>Logins</span></code> contains information about users who have logged in and the chat groups they've joined, while <code class='inline-code-box'><span class='inline-code'>ChatServer</span></code> keeps a list of the users who have connected to the server (a user here can be connected without being logged in: the steps of the process are connect -&gt; login -&gt; logout -&gt; disconnect). Whenever a user disconnects from the server, they must be automatically logged out, and removed from all chat groups they're in. That's done by the <code class='inline-code-box'><span class='inline-code'>super &lt;- remove_user(id: this.id)</span></code> statement inside the body of <code class='inline-code-box'><span class='inline-code'>ChatServer.disconnect(..)</span></code>. The general form of the statement is:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>super</span> &lt;- message;
</section>
</figure>
</code></pre>

<p>where <code class='inline-code-box'><span class='inline-code'>message</span></code> can of course be an arbitrary expression. The execution of the message handler of the dependee is regarded as part of that of the dependant: the two succeed or fail together, and all updates are applied at the same time, so the effects of sending a message are not visible during the execution of the message handler of the dependant, and the order it's issued relative to other update instructions is irrelevant.</p>

<p>If there's more than one dependee, the compiler uses the type of the message to decide which one it should be sent to. If there's any ambiguity (that is, if a message of the given type is accepted by more than one dependee) the compiler will reject your code, as there's no way yet to explicitly specify the intended target.</p>

<p>A message handler can send only one message to each dependee. Sending more than one to the same target will cause a runtime error.</p>


<h3>Execution model and error handling</h3>

<p>The update process triggered by the reception of a message can be divided into several distinct phases. The first step is to dispatch the message to the corresponding message handler, which is similar to the dispatch of a polymorphic function. The next phase is the actual execution of the message handler, during which the state of the automaton does not change, and all the update instructions that are issued are just stored in a separate data structure and left there. If any error occurs during the handler's execution, the message and the set of update commands issued up to that point are just discarded, and the sender of the message is notified of the error. Once the handler returns, all update commands are first checked to make sure they don't violate any integrity constraints. If they do, the message is again discarded and the state of the automaton is left untouched, just as if an error had occurred during the execution of the handler. Otherwise the state of the automaton is updated and the sender is notified that the message was processed successfully.</p>


<h3>Deferred updates: issues and rational</h3>

<p>Message handlers and mutator methods look a lot like ordinary imperative code, and it may be easy to be misled at first by their syntax, but their semantics is in fact completely different. The execution of the update instructions they issue is deferred until the message handler returns, and the order in which they're issued is ignored. A problematic consequence of this execution model is that different parts of an update cannot be easily composed. That happens for two reasons: the most obvious one is that two different updates can both try to set the same member variable (or more generally issue incompatible update instructions) which would cause the whole update to fail. The other, only slightly less obvious but probably more dangerous problem is that they are not aware of one another's changes. Let's illustrate this second issue with an example: say you're building a role-playing game, where the player gradually gains experience and levels up once such experience reaches some predetermined thresholds. The level of the player in turn determines a number of other characteristics, like their maximum health. Let's also say that every time the player levels up, you also want to top up their health. Doing something like this would work fine in an imperative language:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>schema</span> <span class='m'>Game</span> {
  level       : <span class='m'>Int</span> = <span class='n'>0</span>;
  experience  : <span class='m'>Int</span> = <span class='n'>0</span>;
  health      : <span class='m'>Int</span> = max_health(<span class='n'>0</span>);

  ...
}

<span class='k'>using</span> <span class='m'>Game</span> {
  increment_experience(<span class='m'>Int</span> amount) {
    new_experience = experience + amount;
    set experience = new_experience;
    <span class='k'>if</span> new_experience &gt; next_level_experience(level) {
      level_up();
      top_up_health();
    }
  }

  level_up() {
    set level = level + <span class='n'>1</span>;
  }

  top_up_health() {
    set health = max_health(level);
  }
}
</section>
</figure>
</code></pre>

<p>but it doesn't in Cell. The problem lies in the way <code class='inline-code-box'><span class='inline-code'>level_up()</span></code> and <code class='inline-code-box'><span class='inline-code'>top_up_health()</span></code> interact, or rather fail to interact. The <code class='inline-code-box'><span class='inline-code'>level</span></code> member variable is updated in <code class='inline-code-box'><span class='inline-code'>level_up()</span></code> but since that change is not put into effect until later <code class='inline-code-box'><span class='inline-code'>top_up_health()</span></code> erroneously calculates the maximum health based on the old value of <code class='inline-code-box'><span class='inline-code'>level</span></code>, with the result that the player's health bar ends up not being properly refilled.</p>

<p>The choice of such an execution model is probably the most puzzling design decision in the entire language since it makes update code more difficult to write, it adversely affects its modularity, and was not, in any way, dictated by other features of the language. But in spite of its issues, it also has a couple of important advantages.</p>

<p>One major problem with imperative code is that it doesn't lend itself to parallel execution: it's notoriously difficult to write concurrent imperative programs, and even more so for a compiler to (semi-)automatically and safely parallelize the execution of existing code. One much hyped advantage of pure functional programming on the other hand is that it is very well suited to parallel execution: since functions are referentially transparent and have no side effects, two function calls can always be executed in parallel, as long as neither depends on the other's result. And in spite of their imperative syntax, message handlers in Cell are, in fact, pure functions: the only thing that's different about them (apart from the syntax) is the fact that instead of explicitly returning an ordinary value they implicitly return a set of <code class='inline-code-box'><span class='inline-code'>set</span></code>/<code class='inline-code-box'><span class='inline-code'>insert</span></code>/<code class='inline-code-box'><span class='inline-code'>update</span></code>/<code class='inline-code-box'><span class='inline-code'>delete</span></code> commands that are then checked and executed by some compiler-generated code. Both the execution of the message handler and the subsequent checking and execution of the resulting commands can potentially be made to take advantage of multi-core processors safely and with little effort on the programmer's part. That's in addition to the potential inter-automata parallelism: since automata cannot share any mutable state (thanks to the combination of immutability for some data structures and the impossibility of aliasing for others) they can potentially be safely updated concurrently, unless they are wired together as dependant and dependee. Now, just to be clear, what we're talking about here is just leaving the door open for a future implementation to take advantage of parallelism: currently there's no support for concurrency at all, and a fully parallel implementation is going to be a long-term effort.</p>

<p>Another problem is that the execution model of imperative languages, while undoubtedly convenient in simple cases like the example shown above, leads to nasty spaghetti code when programming in the large. Even in a moderately complex real world application, an update may well involve mutating the data structures that encode the state of the application in hundreds of different places. The goal of an update is to transition those data structures from the state they have before the update to the one they're supposed to have when the update is complete. But in order to do so they have to go through many different intermediate states each of which is the result of applying an atomic update to the previous one, and it's also common for specific pieces of information to be mutated several times during a single global update. The vast majority of those partially updated states are inconsistent, since they're by definition the result of updating only a part of the target data structures. But all those intermediate states are visible to the application code, with the result that's very difficult to know, when reading the value of a particular variable, whether such a value is the initial one, the final one, or just an intermediate one. The correctness of the code is highly dependendent on the order in which side effects are carried out, but such order is very difficult to control when updating a large object graph.</p>

<p>Contrast that with what happens when a message handler is executed in Cell. The only observable states of the target automaton are the one before the message is received and the one after the handler has returned. There's no such thing as a temporary, partially updated state: all states are expected to be consistent. There are also no ambiguities either when reading the state of the automaton inside a message handler: it's always the initial state. Of course, that's not always what you want. Sometimes what you actually need is the final value of a variable after the update, as with <code class='inline-code-box'><span class='inline-code'>level</span></code> in <code class='inline-code-box'><span class='inline-code'>top_up_health</span></code>. Other times you need to update a certain piece of information more than once, and you actually need to be able to see those intermediate states. In cases like these the only option available in Cell at the moment is to make a copy of the data structures involved, which you can (functionally) update as many times as you need, and to explicitly pass them around.</p>

<p>I'm happy to admit that this execution model is unproven (it's not used by any other language I know of), and that I fully expect it to turn out to be too restrictive in at least some circumstances. But one thing to keep in mind is that the current model is just a starting point. There are a lot of things that can be done to make it more flexible, without sliding into the complete caos that is one of the most distinctive features of imperative languages. As an example, it would be relatively easy to add the ability to explicitly commit, during the execution of a message handler, all update instructions that have been issued up until a certain point before executing the remaining part of the handler. The overall goal is to try to deviate as little as possible from standard functional programming: to allow observable destructive updates, in order to improve both flexibility and performance, but at the same time to restrict such operations in various ways in order to minimize the unwanted consequences of mutability.</p>


        </article>
      </div>

      <aside id="sidebar">
        <div id='pages'>
          <ul class='toc'>
            <li>Start Here
              <ul class="toc">
                <li><a href='index.html'>Home</a></li>
                <li><a href='overview.html'>Overview</a></li>
                <li><a href='faq.html'>FAQ</a></li>
                <!-- <li><a href='quick.html'>Quick overview</a></li> -->
                <li><a href='example.html'>Introductory example</a></li>
                <li><a href='comparison.html'>A comparison with OOP</a></li>
              </ul>
            </li>
            <li>Rationale
              <ul class="toc">
                <li><a href='relations.html'>Why relations are better than objects</a>
                <!-- <li><a href='state.html'>State</a></li> -->
                <!-- <li><a href='functional.html'>Functional programming</a></li> -->
                <!-- <li><a href='integrity.html'>Encapsulation, equality and data integrity</a></li> -->
              </ul>
            </li>
            <li>Values and Types
              <ul class="toc">
                <li><a href='data.html'>Data</a></li>
                <li><a href='types.html'>Types</a></li>
              </ul>
            </li>
            <li>The Functional Language
              <ul class="toc">
                <li><a href='functions.html'>Functions</a></li>
                <li><a href='imperative.html'>Imperative code</a></li>
                <li><a href='procedures.html'>Procedures</a></li>
                <li><a href='typechecking.html'>Type checking</a></li>
                <li><a href='miscellanea.html'>Protocols, implicit arguments and memoization</a></li>
                <li><a href='benchmarks-functional.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Relational Automata
              <ul class="toc">
                <li><a href='relational.html'>Schemas</a></li>
                <li><a href='data-modeling.html'>Data modeling</a></li>
                <li><a href='methods.html'>Methods</a></li>
                <li><a href='aggregate-functions.html'>Aggregate functions</a></li>
                <li><a href='inheritance.html'>Inheritance and polymorphism</a></li>
                <li><a href='wiring.html'>Wiring automata together</a></li>
                <li><a href='design.html'>Design Process</a></li>
                <li><a href='updates.html'>State updates</a></li>
                <li><a href='using-relational.html'>Using relational automata</a></li>
                <li><a href='benchmarks-relational.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Reactive Automata
              <ul class="toc">
                <li><a href='reactive.html'>Reactive automata</a></li>
                <li><a href='using-reactive.html'>Using reactive automata</a></li>
                <li><a href='reactive-future-work.html'>Future work</a></li>
              </ul>
            </li>
            <li>Interfacing with...
              <ul class="toc">
                <li><a href='interface-cpp.html'>C++</a></li>
                <li><a href='interface-java.html'>Java</a></li>
                <li><a href='interface-cs.html'>C#</a></li>
              </ul>
            </li>
            <li>Network architecture
              <ul class="toc">
                <li><a href='network-architecture.html'>Overview - <strong>NEW</strong></a></li>
              </ul>
            <li>Miscellanea
              <ul class="toc">
                <li><a href='getting-started.html'>Getting started</a></li>
                <li><a href='standard-library.html'>Standard library</a></li>
                <li><a href='status-roadmap.html'>Status and roadmap</a></li>
                <!-- <li><a href='community.html'>Community and contacts</a></li> -->
              </ul>
            </li>

          </ul>
        </div>
      </aside>
    </div>
  </div>
</body>
</html>
