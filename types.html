<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta content="width=device-width,initial-scale=1" name="viewport">
  <meta name="description" content="The Cell Programming Language">

  <title>The Cell Programming Language</title>

  <link href="./fonts.css" rel="stylesheet" type="text/css" media="screen">
  <link href="./main.css" rel="stylesheet">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-113669835-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-113669835-1');
  </script>

</head>

<body>
  <div id="container">

    <header id="topbar">
    </header>

    <div id="main-container">
      <div id="main">
        <article class="content">
<h2>The type system</h2>

<p>In most statically typed languages, whether they be procedural (like C), object-oriented (like Java) or functional (like Haskell), when you want to define your own data structures you start by defining a new type. That type definition acts as a sort of blueprint from which objects or values are created, and only once it is in place you can create instances of that specific type.</p>
<p>In Cell, on the other hand, all values you can ever manipulate belong to a universal set of values that is predefined by the language and cannot be extended in any way. So the role of types is not to act as blueprints from which values are created, but to simply define subsets of that universal set in order to constrain how values are used.</p>
<p>It is useful at this point to just go through a few simple examples. This is how you define a boolean type:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Bool</span> = <span class='k'>true</span>, <span class='k'>false</span>;
</section>
</figure>
</code></pre>

<p>The new type, <code class='inline-code-box'><span class='inline-code'>Bool</span></code>, contains only two values, the two (special) symbols <code class='inline-code-box'><span class='inline-code'>true</span></code> and <code class='inline-code-box'><span class='inline-code'>false</span></code>. Type names can contain both letters and numbers but not underscores, and must begin with an uppercase letter and contain at least a lowercase one. Also, when including a symbol in a type definition, there's no need to prefix it with a colon, because the only purpose of the colon is to avoid ambiguities that cannot arise in this context.</p>
<p>Here are a few more type definitions, all of them defining types comprised of just symbols:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>DayOfTheWeek</span> = monday, tuesday, wednesday, thrusday, friday, saturday, sunday;
<span class='k'>type</span> <span class='m'>WeekEndDay</span>   = saturday, sunday;
<span class='k'>type</span> <span class='m'>WorkWeekDay</span>  = monday, tuesday, wednesday, thrusday, friday;
</section>
</figure>
</code></pre>

<p>Again, each of these types contains only the symbols listed in its definition. But as you have noticed, the same symbols belong to more than one type. So this immediately begs the question, is the symbol <code class='inline-code-box'><span class='inline-code'>sunday</span></code> (for example) that appears in the definition of <code class='inline-code-box'><span class='inline-code'>DayOfTheWeek</span></code>, the same entity that appears in <code class='inline-code-box'><span class='inline-code'>WeekEndDay</span></code>? And the answer is yes, it's exactly the same value. Any value (not just symbols) can belong to any number of types, and there's no such thing as a "most specific type" as in OOP.</p>

<p>Not just that, but as you can see, both <code class='inline-code-box'><span class='inline-code'>WeekEndDay</span></code> and <code class='inline-code-box'><span class='inline-code'>WorkWeekDay</span></code> are subsets of <code class='inline-code-box'><span class='inline-code'>DayOfTheWeek</span></code>, and the compiler will recognize them as such. That is to say, if you have, for example, a function that takes a parameter whose formal type is <code class='inline-code-box'><span class='inline-code'>DayOfTheWeek</span></code>, and you pass as actual argument a variable or an expression whose type is either <code class='inline-code-box'><span class='inline-code'>WeekEndDay</span></code> or <code class='inline-code-box'><span class='inline-code'>WorkWeekDay</span></code>, the typechecker will happily accept your code, because it recognizes that the type of the actual argument is a subset/subtype of the formal one.</p>

<p>That holds true not just for simple enumeration types like the ones above, but for all sorts of types, no matter how complex they are, and that includes recursive ones as well. In other words, the name of a type is completely immaterial; to decide whether one type is a subset of another, the compiler only compares their definitions, not their names. Two types are considered equivalent if and only if they define the same (extensional) set of values, regardless of how they are defined.</p>

<p>But as you'll have certainly realized, there's an obvious problem here. In the general case, the problem of deciding whether a type is a subset of another is undecidable. And indeed, it is pretty easy (if you do it on purpose) to come up with "weird" types that can confuse the compiler. We'll defer a discussion of all this until we have examined the type system in more detail: suffice it to say for now that undecidability does not seem to be a problem at all in practice, and that in any case the type system is safe: the failure to recognize a subtype relation between two types can cause the typechecker to reject a correct program but it will never cause it to accept an invalid one.</p>

<p>We've already seen how to define a type that containts only symbols, which is more or less the structural equivalent of an enumeration in languages like C and C++. Here's how you define the type of all symbols:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Symbol</span> = &lt;+&gt;;
</section>
</figure>
</code></pre>

<p>The notation <code class='inline-code-box'><span class='inline-code'>&lt;+&gt;</span></code> is itself a valid type, and can be used directly in your code. The above definition only create a more syntactically palatable alias for it. It denotes the (infinite) set of all symbols.</p>
<p>The set of all integer numbers is defined in a similar way:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Int</span> = &lt;*..*&gt;;
</section>
</figure>
</code></pre>

<p>Here, again, <code class='inline-code-box'><span class='inline-code'>&lt;*..*&gt;</span></code> is a valid type that can be used directly in the code, and the above definition only creates an alias for it. You can also define subsets of the set of all integers:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Nat</span>    = &lt;<span class='n'>0</span>..*&gt;;
<span class='k'>type</span> <span class='m'>NzNat</span>  = &lt;<span class='n'>1</span>..*&gt;;
<span class='k'>type</span> <span class='m'>Neg</span>    = &lt;*..-<span class='n'>1</span>&gt;;
<span class='k'>type</span> <span class='m'>Byte</span>   = &lt;<span class='n'>0</span>..<span class='n'>255</span>&gt;;
<span class='k'>type</span> <span class='m'>Bit</span>    = &lt;<span class='n'>0</span>..<span class='n'>1</span>&gt;;
<span class='k'>type</span> <span class='m'>Zero</span>   = &lt;<span class='n'>0</span>..<span class='n'>0</span>&gt;;
</section>
</figure>
</code></pre>

<p><code class='inline-code-box'><span class='inline-code'>Nat</span></code> is the set/type of natural numbers, that is, all non-negative integers. <code class='inline-code-box'><span class='inline-code'>NzNat</span></code> is the set of non-zero natural numbers, that is, positive integers. <code class='inline-code-box'><span class='inline-code'>Neg</span></code> includes all negative integer numbers, <code class='inline-code-box'><span class='inline-code'>Byte</span></code> all integers that can fit into an (unsigned) byte, <code class='inline-code-box'><span class='inline-code'>Bit</span></code> just 0 and 1 and <code class='inline-code-box'><span class='inline-code'>Zero</span></code> is a singleton type that contains only 0. You're not restricted to a single range of integers. You can for example define the set of all non-zero integers:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>NzInt</span> = &lt;<span class='n'>1</span>..*&gt;, &lt;*..-<span class='n'>1</span>&gt;;
</section>
</figure>
</code></pre>

<p>The above declaration is also totally equivalent to</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>NzInt</span> = <span class='m'>NzNat</span>, <span class='m'>Neg</span>;
</section>
</figure>
</code></pre>

<p>Since the name of the type is (conceptually at least) irrelevant. In general the comma in a type definition acts as the union operator. The following declaration defines a new type, <code class='inline-code-box'><span class='inline-code'>MyType</span></code>, that is the union of four other types, <code class='inline-code-box'><span class='inline-code'>MyType1</span></code> ... <code class='inline-code-box'><span class='inline-code'>MyType4</span></code>, and is therefore a supertype/superset of all of them:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>MyType</span> = <span class='m'>MyType1</span>, <span class='m'>MyType2</span>, <span class='m'>MyType3</span>, <span class='m'>MyType4</span>;
</section>
</figure>
</code></pre>

<p>Type unions are not restricted to just "homogeneous" types. You can mix any sort of values. Example:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Number</span>       = <span class='m'>Int</span>, <span class='m'>Float</span>;
<span class='k'>type</span> <span class='m'>SymbolOrByte</span> = <span class='m'>Symbol</span>, &lt;<span class='n'>0</span>..<span class='n'>255</span>&gt;;
<span class='k'>type</span> <span class='m'>BooleanOrBit</span> = <span class='k'>true</span>, <span class='k'>false</span>, <span class='m'>Bit</span>;
</section>
</figure>
</code></pre>

<p>The last type that involves only atomic values is the set of all floating point numbers:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Float</span> = &lt;!&gt;;
</section>
</figure>
</code></pre>

<p>Unlike with symbols and integers, there's no way to define subsets of the set of floating point numbers: it's either all of them, or none at all.</p>


<h3>Sequence types</h3>

<p>There's a number of different ways of building types of sequence values. This is the simplest one:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>IntSeq</span> = <span class='m'>Int</span>*;
</section>
</figure>
</code></pre>

<p><code class='inline-code-box'><span class='inline-code'>IntSeq</span></code> comprises all sequences whose elements are integer values, including the empty sequence. The following sequence values are all elements of <code class='inline-code-box'><span class='inline-code'>IntSeq</span></code>:</p>

<figure class="highlight">
<section>
<pre><code>()
(<span class='n'>1</span>, <span class='n'>2</span>, <span class='n'>3</span>)
(-<span class='n'>5</span>, <span class='n'>10</span>, -<span class='n'>15</span>, -<span class='n'>20</span>, <span class='n'>30</span>)
</section>
</figure>
</code></pre>

<p>The notation <code class='inline-code-box'><span class='inline-code'>Int*</span></code> can here be used directly in your code (just like, for example, <code class='inline-code-box'><span class='inline-code'>&lt;0..*&gt;</span></code> or <code class='inline-code-box'><span class='inline-code'>&lt;!&gt;</span></code>) and that is actually the recommended style. In general, the type <code class='inline-code-box'><span class='inline-code'>MyType*</span></code> is the type of all sequences whose elements belong to <code class='inline-code-box'><span class='inline-code'>MyType</span></code>. If you want to exclude the empty sequence you just replace the asterisk with a plus sign:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>NeIntSeq</span> = <span class='m'>Int</span>+;
</section>
</figure>
</code></pre>

<p>You can also define a type that contains only the empty sequence:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>EmptySeq</span> = ();
</section>
</figure>
</code></pre>

<p><code class='inline-code-box'><span class='inline-code'>NeIntSeq</span></code> is the same as <code class='inline-code-box'><span class='inline-code'>IntSeq</span></code> minus the empty sequence, and is therefore a subtype/subset of <code class='inline-code-box'><span class='inline-code'>Int*</span></code>, as is <code class='inline-code-box'><span class='inline-code'>EmptySeq</span></code>. Both <code class='inline-code-box'><span class='inline-code'>Int+</span></code> and <code class='inline-code-box'><span class='inline-code'>()</span></code> notations can be used directly in the code as well. <code class='inline-code-box'><span class='inline-code'>()</span></code> can denote, depending on the context, either the empty sequence (if it appears where an expression is expected) or the singleton type that contains only the empty sequence (if it appears where a type is expected).</p>


<h3>Tuple types</h3>

<p>At the value level, there's no distinction in Cell between tuples and sequences. That's because sequences can hold any kind of values. The following sequence, for example, would be represented as a tuple in languages with a more rigid type system:</p>

<figure class="highlight">
<section>
<pre><code>(<span class='s'>"John"</span>, <span class='s'>"Smith"</span>, <span class='n'>25</span>, <span class='k'>false</span>, <span class='n'>72.5</span>)
</section>
</figure>
</code></pre>

<p>It is useful/necessary though to have a separate tuple type to deal with fixed-length, heterogeneous sequences like the one above. Here's a tuple type that could be used in this case:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>PersonData</span> = (<span class='m'>String</span>, <span class='m'>String</span>, <span class='m'>Nat</span>, <span class='m'>Bool</span>, <span class='m'>Float</span>);
</section>
</figure>
</code></pre>

<p>The type <code class='inline-code-box'><span class='inline-code'>PersonData</span></code> includes only 5-element sequences whose first and second elements are strings, the third is a non-negative integer, the fourth a boolean value and the fifth a floating point number. Contrast that with the standard sequence type, which includes sequences of any length (with the possible exclusion of the empty sequence), but cannot constrain the type of the elements based on their position.</p>


<h3>Set types</h3>

<p>Set types are similar to sequence type. The type of the elements is written between brackets, with a <code class='inline-code-box'><span class='inline-code'>+</span></code> sign before it if you want to exclude the empty set:</p>

<figure class="highlight">
<section>
<pre><code>[<span class='m'>Int</span>]     <span class='c'>// All sets of integers</span>
[+<span class='m'>Byte</span>]   <span class='c'>// All non-empty sets of bytes</span>
[]        <span class='c'>// The singleton type containing only the empty set/relation</span>
[&lt;<span class='n'>0</span>..<span class='n'>9</span>&gt;]  <span class='c'>// All sets containing only single-digit integers</span>
</section>
</figure>
</code></pre>


<h3>Binary relation types</h3>

<p>Binary relation types too are written between brackets, with the two argument types separated by a comma. A type like <code class='inline-code-box'><span class='inline-code'>[Int, String]</span></code> includes all the following relation values (among infinitely many others, of course):</p>

<figure class="highlight">
<section>
<pre><code>[]
[<span class='n'>0</span>, <span class='s'>"A"</span>]
[<span class='n'>0</span>, <span class='s'>"A"</span>; <span class='n'>1</span>, <span class='s'>"B"</span>]
</section>
</figure>
</code></pre>

<p>You can exclude the empty set/relation value from your type in the same way as set types: <code class='inline-code-box'><span class='inline-code'>[+Int, String]</span></code> contains all the elements of <code class='inline-code-box'><span class='inline-code'>[Int, String]</span></code> except the empty set/relation (and is therefore a subset/subtype of <code class='inline-code-box'><span class='inline-code'>[Int, String]</span></code>).</p>
<p>Relation types also have "polymorphic" variants: the type <code class='inline-code-box'><span class='inline-code'>[Int, String; Symbol, Float]</span></code>, for example, includes the following values:</p>

<figure class="highlight">
<section>
<pre><code>[]
[<span class='n'>0</span>, <span class='s'>"A"</span>; <span class='n'>1</span>, <span class='s'>"B"</span>]
[<span class='a'>:pi</span>, <span class='n'>3.14159</span>; <span class='a'>:e</span>, <span class='n'>2.71828</span>]
[<span class='n'>0</span>, <span class='s'>"A"</span>; <span class='n'>1</span>, <span class='s'>"B"</span>; <span class='a'>:pi</span>, <span class='n'>3.14159</span>; <span class='a'>:e</span>, <span class='n'>2.71828</span>]
</section>
</figure>
</code></pre>

<p>but not the following ones:</p>

<figure class="highlight">
<section>
<pre><code>[<span class='n'>2</span>, <span class='n'>1.41421</span>]  <span class='c'>// Relations with Int/Float entries are not included</span>
[<span class='a'>:a</span>, <span class='s'>"A"</span>]     <span class='c'>// Relations with Symbol/String entries are not included</span>
</section>
</figure>
</code></pre>

<p>You can of course have any number of alternatives in a polymorphic relation type:</p>

<figure class="highlight">
<section>
<pre><code>[<span class='m'>TypeA</span>, <span class='m'>TypeB</span>; <span class='m'>TypeC</span>, <span class='m'>TypeD</span>; <span class='m'>TypeE</span>, <span class='m'>TypeF</span>; <span class='m'>TypeG</span>, <span class='m'>TypeH</span>]
</section>
</figure>
</code></pre>

<p>Polymorphic relation types may seem rather bizzare at first, but they are actually very useful (We'll see exactly why in one of the next chapters).</p>


<h3>Ternary relation types</h3>

<p>Ternary relation types are almost the same as binary relation types, the only difference being that they have three arguments instead of two. They too can be polymorphic and exclude the empty set/relation. A couple examples:</p>

<figure class="highlight">
<section>
<pre><code>[<span class='m'>String</span>, <span class='m'>Int</span>, <span class='m'>Float</span>]
[+<span class='m'>String</span>, <span class='m'>Int</span>, <span class='m'>Float</span>; <span class='m'>Symbol</span>, <span class='m'>Float</span>*, [+<span class='m'>Int</span>]]
</section>
</figure>
</code></pre>


<h3>Map types</h3>

<p>Map types are similar to binary relation types, but they only includes maps, that is, binary relations with no duplicates in the left column. They can exclude the empty relation, but they don't have polymorphic variants. A few examples:</p>

<figure class="highlight">
<section>
<pre><code>[<span class='m'>Int</span> -&gt; <span class='m'>String</span>]
[+<span class='m'>Int</span> -&gt; <span class='m'>Float</span>]
[(<span class='m'>Int</span>, <span class='m'>Int</span>) -&gt; <span class='m'>Float</span>*]
</section>
</figure>
</code></pre>


<h3>Record types</h3>

<p>Just like tuples have their own type, even though at the value level they are just sequences, so records have types that are distinct from standard relation and map types, even though record values are just a subset of binary relation values. Their syntax should be self-explanatory:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Point3D</span> = (x: <span class='m'>Int</span>, y: <span class='m'>Int</span>, z: <span class='m'>Int</span>);
<span class='k'>type</span> <span class='m'>Rect</span>    = (left: <span class='m'>Float</span>, right: <span class='m'>Float</span>, top: <span class='m'>Float</span>, bottom: <span class='m'>Float</span>);
<span class='k'>type</span> <span class='m'>DateRec</span> = (day: &lt;<span class='n'>1</span>..<span class='n'>31</span>&gt;, month: &lt;<span class='n'>1</span>..<span class='n'>12</span>&gt;, year: <span class='m'>Int</span>);
</section>
</figure>
</code></pre>

<p>You can also tag some fields as being optional, by adding a question mark after their type. In the following type definition, for example, both <code class='inline-code-box'><span class='inline-code'>middle_name</span></code> and <code class='inline-code-box'><span class='inline-code'>date_of_death</span></code> are optional:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>PersonRecord</span> = (
  first_name:     <span class='m'>String</span>,
  middle_name:    <span class='m'>String</span>?,
  last_name:      <span class='m'>String</span>,
  date_of_birth:  <span class='m'>Date</span>,
  date_of_death:  <span class='m'>Date</span>?
);
</section>
</figure>
</code></pre>


<h3>Tagged value types</h3>

<p>Finally we have tagged value types. Here are a few example:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Distance</span>   = meters(<span class='m'>Float</span>);
<span class='k'>type</span> <span class='m'>TimeSpan</span>   = seconds(<span class='m'>Float</span>);
<span class='k'>type</span> <span class='m'>String</span>     = string(<span class='m'>Nat</span>*);
<span class='k'>type</span> <span class='m'>Fraction</span>   = fraction((<span class='m'>Int</span>, <span class='m'>NzNat</span>));

<span class='k'>type</span> <span class='m'>Point</span>      = cartesian_point((x: <span class='m'>Float</span>, y: <span class='m'>Float</span>)),
                  polar_point((ro: <span class='m'>Float</span>, theta: <span class='m'>Float</span>));

<span class='k'>type</span> <span class='m'>Rectangle</span>  = rectangle((
                    bottom_left: <span class='m'>Point</span>,
                    width: <span class='m'>Float</span>,
                    height: <span class='m'>Float</span>
                  ));
</section>
</figure>
</code></pre>

<p>The same syntactic sugar provided for tagged records and tuples is available here as well. The following type definitions are completely equivalent to the ones above:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Fraction</span>   = fraction(<span class='m'>Int</span>, <span class='m'>NzNat</span>);

<span class='k'>type</span> <span class='m'>Point</span>      = cartesian_point(x: <span class='m'>Float</span>, y: <span class='m'>Float</span>),
                  polar_point(ro: <span class='m'>Float</span>, theta: <span class='m'>Float</span>);

<span class='k'>type</span> <span class='m'>Rectangle</span>  = rectangle(
                    bottom_left: <span class='m'>Point</span>,
                    width:       <span class='m'>Float</span>,
                    height:      <span class='m'>Float</span>
                  );
</section>
</figure>
</code></pre>

<p>There's also a type for values that are tagged with any symbol:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>TaggedInt</span>    = &lt;+&gt;(<span class='m'>Int</span>);
<span class='k'>type</span> <span class='m'>TaggedFloat</span>  = &lt;+&gt;(<span class='m'>Float</span>);
</section>
</figure>
</code></pre>

<p>A type like <code class='inline-code-box'><span class='inline-code'>TaggedInt</span></code> above includes, for example, all the following values (and infinitely many more, of course):</p>

<figure class="highlight">
<section>
<pre><code><span class='a'>:meters</span>(<span class='n'>100</span>)
<span class='a'>:miles</span>(<span class='n'>2</span>)
<span class='a'>:seconds</span>(<span class='n'>60</span>)
<span class='a'>:dollars</span>(<span class='n'>1000000000</span>)
</section>
</figure>
</code></pre>


<h3>Inline types</h3>

<p>In general, anything that can appear after the <code class='inline-code-box'><span class='inline-code'>=</span></code> sign in a type definition is a type in its own right, and can be used directly in the code. All the following type expressions, for example, can not only be nested inside another type expression, but also used in places like function signatures:</p>

<figure class="highlight">
<section>
<pre><code>&lt;+&gt;
&lt;<span class='n'>0</span>..<span class='n'>9</span>&gt;
<span class='m'>Int</span>*
[+<span class='m'>Symbol</span>]
[<span class='m'>Int</span>, <span class='m'>String</span>]
()
[]
(x: <span class='m'>Int</span>, y: <span class='m'>Int</span>)+

<span class='c'>// The type of all non-empty sets of non-empty</span>
<span class='c'>// sequences of Int/Float/String tuples</span>
[+(<span class='m'>Int</span>, <span class='m'>Float</span>, <span class='m'>String</span>)+]
</section>
</figure>
</code></pre>

<p>There are three exceptions to this rule: symbols, tagged types and type unions. To turn them into standalone types, they have to be enclosed by <code class='inline-code-box'><span class='inline-code'>&lt;</span></code> and <code class='inline-code-box'><span class='inline-code'>&gt;</span></code>. The following, for example, are valid types:</p>

<figure class="highlight">
<section>
<pre><code>&lt;on, off&gt;
&lt;up, down, left, right&gt;
&lt;<span class='k'>true</span>&gt;
&lt;nothing&gt;
&lt;cart_point(x: <span class='m'>Float</span>, y: <span class='m'>Float</span>), polar_point(ro: <span class='m'>Float</span>, theta: <span class='m'>Float</span>)&gt;
&lt;nothing, maybe(<span class='m'>Int</span>)&gt;
</section>
</figure>
</code></pre>

<p>but they wouldn't be if the <code class='inline-code-box'><span class='inline-code'>&lt;</span></code> and <code class='inline-code-box'><span class='inline-code'>&gt;</span></code> signs where removed. Since they are types in their own right, they can also be nested inside other types:</p>

<figure class="highlight">
<section>
<pre><code>[<span class='m'>String</span> -&gt; &lt;<span class='m'>Int</span>, <span class='m'>Float</span>&gt;*]
[<span class='m'>String</span>, &lt;<span class='m'>Int</span>, null&gt;*]
(x: &lt;<span class='m'>Int</span>, <span class='m'>Float</span>&gt;, y: &lt;<span class='m'>Int</span>, <span class='m'>Float</span>&gt;)
</section>
</figure>
</code></pre>

<p>Incidentally, take notice of the difference between these two types:</p>

<figure class="highlight">
<section>
<pre><code>&lt;<span class='m'>Int</span>, <span class='m'>Float</span>&gt;*
&lt;<span class='m'>Int</span>*, <span class='m'>Float</span>*&gt;
</section>
</figure>
</code></pre>

<p>The first is the type of all sequences whose elements are either integer or floating point numbers: it includes also sequences that contain a mix of both. The second type includes sequences of only integers and sequences of only floating point numbers, but not mixed ones. The second type is obviously a subtype of the first.</p>


<h3>Parametric type declarations</h3>

<p>Let's say we need to define a data structure for binary trees of integer numbers. We could use the symbol <code class='inline-code-box'><span class='inline-code'>empty_bin_tree</span></code> to denote the empty tree, and a tagged triple composed of an integer and two subtrees for internal nodes. Our type declaration would then look like this:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>IntBinTree</span> = empty_bin_tree,
                  bin_tree(<span class='m'>Int</span>, <span class='m'>IntBinTree</span>, <span class='m'>IntBinTree</span>);
</section>
</figure>
</code></pre>

<p>To make this declaration more general, so that it could be used with values of any type, not just integers, we will need to add a parameter to it:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>BinTree</span>[<span class='u'>T</span>]  = empty_bin_tree,
                   bin_tree(<span class='u'>T</span>, <span class='m'>BinTree</span>[<span class='u'>T</span>], <span class='m'>BinTree</span>[<span class='u'>T</span>]);
</section>
</figure>
</code></pre>

<p>Here <code class='inline-code-box'><span class='inline-code'>T</span></code> is a type variable, and <code class='inline-code-box'><span class='inline-code'>BinTree[T]</span></code> a parametric type. A type variables is represented by a standalone uppercase letter. To instantiate a parametric type, just replace the type variable between brackets with a normal type:</p>

<figure class="highlight">
<section>
<pre><code><span class='c'>// Binary trees of integers</span>
<span class='m'>BinTree</span>[<span class='m'>Int</span>]

<span class='c'>// Binary trees of floating point numbers</span>
<span class='m'>BinTree</span>[<span class='m'>Float</span>]

<span class='c'>// Binary trees of either integer or floating point numbers</span>
<span class='m'>BinTree</span>[&lt;<span class='m'>Int</span>, <span class='m'>Float</span>&gt;]

<span class='c'>// Binary trees of triples of integers</span>
<span class='m'>BinTree</span>[(<span class='m'>Int</span>, <span class='m'>Int</span>, <span class='m'>Int</span>)]
</section>
</figure>
</code></pre>

<p>A parametric type can of course have any number of type variables, not just one:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Result</span>[<span class='u'>V</span>, <span class='u'>E</span>] = success(<span class='u'>V</span>), failure(<span class='u'>E</span>);
</section>
</figure>
</code></pre>


<h3>Subtyping</h3>

<p>Let's now come back to the subject of subtyping. As mentioned before, a type <code class='inline-code-box'><span class='inline-code'>T</span></code> is a subset/subtype of another type <code class='inline-code-box'><span class='inline-code'>T'</span></code> if every element of <code class='inline-code-box'><span class='inline-code'>T</span></code> is also an element of <code class='inline-code-box'><span class='inline-code'>T'</span></code>, and the two are equivalent if they are both subtypes of each other, that is, if every element of <code class='inline-code-box'><span class='inline-code'>T</span></code> belongs to <code class='inline-code-box'><span class='inline-code'>T'</span></code> and vice versa.</p>
<p>The problem with using the standard mathematical notion of subset and superset to define subtyping conformance is that such notion is, in the general case, undecidable: there's no algorithm, let alone an efficient one, that can decide, for all pairs of types/sets if one is a subset of the other. When the typechecker fails to prove a valid subtype relationship it simply rejects what might otherwise be a valid program, but it never accepts an invalid one, so the system is safe, just more restrictive that it should, in theory, be.</p>
<p>Luckily, it turns out that, in practice, the types that are used in normal code are simple enough that even a not particularly sofisticated typechecker has no difficulty dealing with the vast majority of cases, and it can run into trouble only in situations that are far outside the reach of any nominative, deterministic type system I know of.</p>
<p>As an example of what could trip up the compiler, consider the following type definitions:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>ProbType1</span> = (<span class='m'>Ta1</span>, <span class='m'>Tb1</span>),
                 (<span class='m'>Ta1</span>, <span class='m'>Tb2</span>),
                 (<span class='m'>Ta2</span>, <span class='m'>Tb1</span>),
                 (<span class='m'>Ta2</span>, <span class='m'>Tb2</span>);

<span class='k'>type</span> <span class='m'>ProbType2</span> = (&lt;<span class='m'>Ta1</span>, <span class='m'>Ta2</span>&gt;, &lt;<span class='m'>Tb1</span>, <span class='m'>Tb2</span>&gt;);
</section>
</figure>
</code></pre>

<p>where <code class='inline-code-box'><span class='inline-code'>Ta1</span></code>, <code class='inline-code-box'><span class='inline-code'>Ta2</span></code>, <code class='inline-code-box'><span class='inline-code'>Tb1</span></code> and <code class='inline-code-box'><span class='inline-code'>Tb2</span></code> are types defined elsewhere. <code class='inline-code-box'><span class='inline-code'>ProbType1</span></code> and <code class='inline-code-box'><span class='inline-code'>ProbType2</span></code> are obviously the same type, but the typechecker is unable to figure that out. It can easily prove that <code class='inline-code-box'><span class='inline-code'>ProbType1</span></code> is a subset of <code class='inline-code-box'><span class='inline-code'>ProbType2</span></code>, but not the other way round. The same problem can present itself with record types:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>ProbType3</span> = (a: <span class='m'>Ta1</span>, b: <span class='m'>Tb1</span>),
                 (a: <span class='m'>Ta1</span>, b: <span class='m'>Tb2</span>),
                 (a: <span class='m'>Ta2</span>, b: <span class='m'>Tb1</span>),
                 (a: <span class='m'>Ta2</span>, b: <span class='m'>Tb2</span>);

<span class='k'>type</span> <span class='m'>ProbType4</span> = (a: &lt;<span class='m'>Ta1</span>, <span class='m'>Ta2</span>&gt;, b: &lt;<span class='m'>Tb1</span>, <span class='m'>Tb2</span>&gt;);
</section>
</figure>
</code></pre>

<p>Here too the compiler can figure out that <code class='inline-code-box'><span class='inline-code'>ProbType3</span></code> is a subset of <code class='inline-code-box'><span class='inline-code'>ProbType4</span></code>, but not vice versa.</p>
<p>In both cases the underlying problem is that when the supertype is a union type, like so:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>SuperType</span> = <span class='m'>Type1</span>, <span class='m'>Type2</span>, ..., <span class='m'>TypeN</span>;
</section>
</figure>
</code></pre>

<p>what the typechecker currently does is to compare the subtype (or each of its alternatives, if the subtype is a type union) to each of <code class='inline-code-box'><span class='inline-code'>Type1</span></code> ... <code class='inline-code-box'><span class='inline-code'>TypeN</span></code>, and give up if none of them is actually a supertype, and this naive algorithm clearly doesn't cover cases like the ones above.</p>
<p>Yet in practice these situations are very easy to avoid. For instance, during the development of the Cell compiler, which is currently the largest (by far) piece of software written in Cell, only twice did the typechecker fail to recognize a valid subtype relation, and, in both cases, the issue was resolved in a couple of minutes with a minor refactoring of the type declarations involved. And even that could have been avoided by just making the compiler a little smarter (which I hope to eventually do). For now though, just avoid type declarations like these (they are simplified versions of the ones I actually had problems with):</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>BadType1</span> = a_tag(<span class='m'>TypeA</span>), a_tag(<span class='m'>TypeB</span>);
<span class='k'>type</span> <span class='m'>BadType2</span> = (field1: <span class='m'>TypeA</span>, field2: <span class='m'>TypeB</span>),
                (field1: <span class='m'>TypeA</span>, field2: <span class='m'>TypeC</span>);
</section>
</figure>
</code></pre>

<p>and use instead the following ones:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>GoodType1</span>  = a_tag(&lt;<span class='m'>TypeA</span>, <span class='m'>TypeB</span>&gt;);
<span class='k'>type</span> <span class='m'>GoodType2</span>  = (field1: <span class='m'>TypeA</span>, field2: &lt;<span class='m'>TypeB</span>, <span class='m'>TypeC</span>&gt;);
</section>
</figure>
</code></pre>

<p>which are equivalent, but more typechecker-friendly, since the compiler can figure out that <code class='inline-code-box'><span class='inline-code'>BadType1</span></code> and <code class='inline-code-box'><span class='inline-code'>BadType2</span></code> are subsets of <code class='inline-code-box'><span class='inline-code'>GoodType1</span></code> and <code class='inline-code-box'><span class='inline-code'>GoodType2</span></code> (respectively), but not vice versa.</p>


<h3>Standard types</h3>

<p>Let's conclude this chapter with a quick review of some of the types that are defined in the standard library. Some are new, others have already been mentioned before. Let's start with atomic values:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Symbol</span>   = &lt;+&gt;;      <span class='c'>// All symbols</span>
<span class='k'>type</span> <span class='m'>Int</span>      = &lt;*..*&gt;;   <span class='c'>// All integers</span>
<span class='k'>type</span> <span class='m'>Float</span>    = &lt;!&gt;;      <span class='c'>// All floating point numbers</span>
</section>
</figure>
</code></pre>

<p>We've already seen them before. Some of their subsets are especially important:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Bool</span>   = <span class='k'>true</span>, <span class='k'>false</span>;  <span class='c'>// Standard boolean type</span>
<span class='k'>type</span> <span class='m'>True</span>   = <span class='k'>true</span>;         <span class='c'>// Just the truth value</span>
<span class='k'>type</span> <span class='m'>False</span>  = <span class='k'>false</span>;        <span class='c'>// Just the falsehood value</span>

<span class='k'>type</span> <span class='m'>Nat</span>    = &lt;<span class='n'>0</span>..*&gt;;   <span class='c'>// Natural numbers (ie, non-negative integers)</span>
<span class='k'>type</span> <span class='m'>NzNat</span>  = &lt;<span class='n'>1</span>..*&gt;;   <span class='c'>// Non-zero natural numbers</span>

<span class='k'>type</span> <span class='m'>Bit</span>    = &lt;<span class='n'>0</span>..<span class='n'>1</span>&gt;;   <span class='c'>// Just 0 and 1</span>
<span class='k'>type</span> <span class='m'>Byte</span>   = &lt;<span class='n'>0</span>..<span class='n'>255</span>&gt;; <span class='c'>// Integers that can fit in an unsigned byte</span>
</section>
</figure>
</code></pre>

<p>Singleton types like <code class='inline-code-box'><span class='inline-code'>True</span></code> and <code class='inline-code-box'><span class='inline-code'>False</span></code> may seem pointless at first, but they are actually pretty important (We'll see why when we discuss typechecking).</p>
<p>The following is the "universal" type, the one that includes all values. It is a superset of any other type:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Any</span>  = <span class='m'>Symbol</span>,           <span class='c'>// Symbols</span>
            <span class='m'>Int</span>,              <span class='c'>// Integers</span>
            <span class='m'>Float</span>,            <span class='c'>// Floating point numbers</span>
            <span class='m'>Any</span>*,             <span class='c'>// Sequences</span>
            [<span class='m'>Any</span>],            <span class='c'>// Sets</span>
            [<span class='m'>Any</span>, <span class='m'>Any</span>],       <span class='c'>// Binary relations</span>
            [<span class='m'>Any</span>, <span class='m'>Any</span>, <span class='m'>Any</span>],  <span class='c'>// Ternary relations</span>
            &lt;+&gt;(<span class='m'>Any</span>);         <span class='c'>// Tagged values</span>
</section>
</figure>
</code></pre>

<p>The next types are useful when writing functions that can fail to produce a result. The <code class='inline-code-box'><span class='inline-code'>Maybe</span></code> type is standard in any functional programming language:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Maybe</span>[<span class='u'>T</span>]   = nothing, just(<span class='u'>T</span>);

<span class='k'>type</span> <span class='m'>Nothing</span>    = nothing;
<span class='k'>type</span> <span class='m'>Just</span>[<span class='u'>T</span>]    = just(<span class='u'>T</span>);
</section>
</figure>
</code></pre>

<p>and the <code class='inline-code-box'><span class='inline-code'>Result</span></code> type is a slightly more capable version of it, that can return either a result or an error:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Result</span>[<span class='u'>V</span>, <span class='u'>E</span>] = success(<span class='u'>V</span>), failure(<span class='u'>E</span>);

<span class='k'>type</span> <span class='m'>Success</span>[<span class='u'>V</span>]   = success(<span class='u'>V</span>);
<span class='k'>type</span> <span class='m'>Failure</span>[<span class='u'>E</span>]   = failure(<span class='u'>E</span>);
</section>
</figure>
</code></pre>

<p>An alternative to <code class='inline-code-box'><span class='inline-code'>Maybe</span></code> is the <code class='inline-code-box'><span class='inline-code'>Opt</span></code> type. It represents the absence of value with an empty sequence, and its presence with a 1-element tuple. It may be preferable (in some cases, at least) because standard sequence manipulation constructs and functions can be applied to it as well. Here's the definition:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Opt</span>[<span class='u'>T</span>] = (), (<span class='u'>T</span>);
</section>
</figure>
</code></pre>

<p>Finally we have the standard string type:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>String</span> = string(<span class='m'>Nat</span>*);
</section>
</figure>
</code></pre>

<p>and the type of all 7-bit ascii strings, which is obviously a subset of <code class='inline-code-box'><span class='inline-code'>String</span></code>:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Ascii</span> = string(&lt;<span class='n'>0</span>..<span class='n'>127</span>&gt;*);
</section>
</figure>
</code></pre>

<p>There are also types for dates and time:</p>

<figure class="highlight">
<section>
<pre><code><span class='k'>type</span> <span class='m'>Time</span> = time(<span class='m'>Int</span>);
<span class='k'>type</span> <span class='m'>Date</span> = date(<span class='m'>Int</span>);
</section>
</figure>
</code></pre>


        </article>
      </div>

      <aside id="sidebar">
        <div id='pages'>
          <ul class='toc'>
            <li>Start Here
              <ul class="toc">
                <li><a href='index.html'>Home</a></li>
                <li><a href='overview.html'>Overview</a></li>
                <li><a href='faq.html'>FAQ</a></li>
                <!-- <li><a href='quick.html'>Quick overview</a></li> -->
                <li><a href='example.html'>Introductory example</a></li>
                <li><a href='comparison.html'>A comparison with OOP</a></li>
              </ul>
            </li>
            <li>Rationale
              <ul class="toc">
                <li><a href='relations.html'>Why relations are better than objects</a>
                <!-- <li><a href='state.html'>State</a></li> -->
                <!-- <li><a href='functional.html'>Functional programming</a></li> -->
                <!-- <li><a href='integrity.html'>Encapsulation, equality and data integrity</a></li> -->
              </ul>
            </li>
            <li>Values and Types
              <ul class="toc">
                <li><a href='data.html'>Data</a></li>
                <li><a href='types.html'>Types</a></li>
              </ul>
            </li>
            <li>The Functional Language
              <ul class="toc">
                <li><a href='functions.html'>Functions</a></li>
                <li><a href='imperative.html'>Imperative code</a></li>
                <li><a href='procedures.html'>Procedures</a></li>
                <li><a href='typechecking.html'>Type checking</a></li>
                <li><a href='miscellanea.html'>Protocols, implicit arguments and memoization</a></li>
                <li><a href='benchmarks-functional.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Relational Automata
              <ul class="toc">
                <li><a href='relational.html'>Schemas</a></li>
                <li><a href='data-modeling.html'>Data modeling</a></li>
                <li><a href='methods.html'>Methods</a></li>
                <li><a href='aggregate-functions.html'>Aggregate functions</a></li>
                <li><a href='inheritance.html'>Inheritance and polymorphism</a></li>
                <li><a href='wiring.html'>Wiring automata together</a></li>
                <li><a href='design.html'>Design Process</a></li>
                <li><a href='updates.html'>State updates</a></li>
                <li><a href='using-relational.html'>Using relational automata</a></li>
                <li><a href='benchmarks-relational.html'>Benchmarks</a></li>
              </ul>
            </li>
            <li>Reactive Automata
              <ul class="toc">
                <li><a href='reactive.html'>Reactive automata</a></li>
                <li><a href='using-reactive.html'>Using reactive automata</a></li>
                <li><a href='reactive-future-work.html'>Future work</a></li>
              </ul>
            </li>
            <li>Interfacing with...
              <ul class="toc">
                <li><a href='interface-cpp.html'>C++</a></li>
                <li><a href='interface-java.html'>Java</a></li>
                <li><a href='interface-cs.html'>C#</a></li>
              </ul>
            </li>
            <li>Miscellanea
              <ul class="toc">
                <li><a href='getting-started.html'>Getting started</a></li>
                <li><a href='status-roadmap.html'>Status and roadmap</a></li>
                <!-- <li><a href='community.html'>Community and contacts</a></li> -->
              </ul>
            </li>

          </ul>
        </div>
      </aside>
    </div>
  </div>
</body>
</html>
